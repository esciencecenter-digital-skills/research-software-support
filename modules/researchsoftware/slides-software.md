---
title: What is software?
type: slides
order: 1
---

<!-- .slide: data-state="title" -->

# What is software?

===

<!-- .slide: data-state="standard" -->

## Some history
<center>
<img class="rotate-90" src="media/Lochkarte_Tanzorgel_cutout.jpg"  width="40%" data-rotate="90">
</center>
<small>Photo by <a href="https://www.wikidata.org/wiki/Q106975068">Stefan Kuhn</a> on <a href="https://commons.wikimedia.org/wiki/File:Lochkarte_Tanzorgel.jpg">Wikimedia</a>
</small>


Note:
Who knows what this is?

See next slide for explanation.

==

<!-- .slide: data-state="standard" -->

## Some history
<center>
<img class="" src="media/Lochkarte_Tanzorgel.jpg"  width="40%">
</center>
<small>Photo by <a href="https://www.wikidata.org/wiki/Q106975068">Stefan Kuhn</a> on <a href="https://commons.wikimedia.org/wiki/File:Lochkarte_Tanzorgel.jpg">Wikimedia</a>
</small>


Note:
A street organ's machinery is instructed by long "books" of cardboard with holes punched in it. Each hole triggers one specific note and/or instrument to play in the organ. In this way the organ can be "programmed" and the punch book can be considered the software of the organ.

==

<!-- .slide: data-state="standard" -->

## Some history
<center>
<iframe width="560" height="315" src="https://youtu.be/wbLuMd5zYww?si=3o0zptLY4c3i1ppk&t=275" title="" frameBorder="0"   allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"  allowFullScreen></iframe>
</center>

<small><a href="https://youtu.be/wbLuMd5zYww?si=3o0zptLY4c3i1ppk&t=275">https://youtu.be/wbLuMd5zYww?si=3o0zptLY4c3i1ppk&t=275</a>
</small>

<!-- Speaker notes -->
Note:
A long book of cardboard with holes punched in it is used to give the barrel organ instructions on which mechanical instruments should play what note at which time. 

===

<!-- .slide: data-state="standard" -->

## Some history

<center>
<img src="media/Punch-card-cobol.jpg" width="55%">
</center>

<small>Photo by Rainer Gerhards on <a href="https://commons.wikimedia.org/wiki/File:Punch-card-cobol.jpg">Wikimedia</a>
</small>


<!-- Speaker notes -->
Note:
Who knows what this is? Looks similar to the previous thing, right? This is software.

==

<!-- .slide: data-state="standard" -->

## Some history

<center>
<iframe width="560" height="315" src="https://youtu.be/kaQmAybWn-w?si=zRmBx4Df68gWuw3e&t=540" title="" frameBorder="0"   allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"  allowFullScreen></iframe>
</center>
<small><a href="https://youtu.be/kaQmAybWn-w?si=zRmBx4Df68gWuw3e&t=540">https://youtu.be/kaQmAybWn-w?si=zRmBx4Df68gWuw3e&t=540</a>
</small>

<!-- Speaker notes -->
Note:
This software was written using special typewriters that would punch holes in cardboard cards. It would encode instructions to the computer hardware, in this case the hardware is a UNIVAC 90/30 (1974). One punchcard from the old UNIVAC 90/30 system would hold a single line of code. A program usually consisted of a whole stack of these cards.

==

<!-- .slide: data-state="standard" -->

## Some history

<center>
<iframe width="560" height="315" src="https://youtu.be/SYpPPIsxq64?si=m__szsXBDI6SP5kx&t=793" title="" frameBorder="0"   allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"  allowFullScreen></iframe>
</center>
<small><a href="https://youtu.be/SYpPPIsxq64?si=m__szsXBDI6SP5kx&t=793">https://youtu.be/SYpPPIsxq64?si=m__szsXBDI6SP5kx&t=793</a>
</small>

<!-- Speaker notes -->
Note:
These punchcards would be loaded into the computer to instruct which parts of the hardware should act in which way and when. In this video, you see an even older computer, the Harwell Dekatron or W.I.T.C.H. (1952), which reads its software from perforated paper tape. 

===

<!-- .slide: data-state="standard" -->

## Software now

<center>
<img src="media/software-development.jpg" width="55%">
</center>
<small>Photo by <a href="https://unsplash.com/@cdr6934?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Chris Ried</a> on <a href="https://unsplash.com/photos/a-computer-screen-with-a-bunch-of-code-on-it-ieic5Tq8YMk?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a></small>
  
<!-- Speaker notes -->
Note:
These days, software usually gets written using a computer, in a text editor program, so the act of writing software requires software itself. The software is stored in memory and on a hard disk rather than on cardboard (remember, one card per line...), but it basically still does the same: Software is a set of instructions that tells hardware what to do.

==

<!-- .slide: data-state="empty-slide" data-background-iframe="https://www.online-python.com/" -->

<!-- Speaker notes -->
Note:
On this website you can experiment with writing software (python code) yourself: 
https://www.online-python.com

===

<!-- .slide: data-state="standard" -->

## Software is like other data

Software is ...

- stored as bits 
- read, loaded and processed
- can be input, and can be output


<!-- Speaker notes -->
Note:
Software is stored as bits and read from disk, loaded into memory and processed in exactly the same way as other data. Software can be input, and software can be output. In fact, one of the major breakthroughs in computer science was when people realized that the instructions of the machine could be handled and stored the same as the data that it operated on. 


===

<!-- .slide: data-state="standard" -->

## Software is <u>not</u> 'just' data

Software is...

- **complex**: code is creatively generated, interconnected and multi-layered
- **interdependent**: it builds upon and therefore depends on other software
- **executable**: it is not static, but can be run (to process data)
- **dynamic**: it can (and will) break soon, needs to be updated 

<!-- Speaker notes -->
Note:
While technically, software is a special kind of data (in that it is representation of information in a digital state), they are in essence quite different.

Software and data both are digital objects, sharing certain characteristics: they can be assigned a DOI, and they can have a license.

Software is quite different from data, however. Consider:

- Complexity; it is not a single file, but a collection of files that are interconnected and multi-layered, and do not necessarily stand on their own. Software is also the result of a creative process that provides a tool to do something, and not the result of a measurement or observation.
- Interdependence; software is often built using other software, and rarely built completely from scratch. This makes it dependent on other existing applications, which themselves may also change over time.
- Executability; software is in its dryest form a set of instructions that can be an archive of a procedure. However, the main goal of software is that these instructions can be executed. Data, by contrast, stand on their own.
- Dynamic vs static; its interdependence and context-dependency drives software to require maintenance to retain its value, and this maintenance is not straightforward. Maintenance is also counter to academic culture; it does not fit in existing structures (both in terms of reward/recognition, but also in terms of funding and understanding of what is needed). Versioning of software is very common, while data is often static (though versions may happen).

===

<!-- .slide: data-state="standard" -->

## Software vs data management

- Software is a **living thing**
- Some FAIR data management practices apply to software
- Many FAIR principles do not apply easily to software
- Good data management will not ensure good software management

Note:
The different nature of software also provides opportunities but also requires extra thought on its management.
Software is a living thing, and therefore it is easier to adopt good practices early on.
Crucially, there is a community driven openness in software that long predates the open science movement.
This is not to say that software is inherently open, but that there is a broad open culture, which also comes with existing tools and pathways to facilitate openness and transparency.
Consider GitHub (and other code hosting platforms), which are designed for this purpose.
Consider also version control software, a good software development practice that builds in provenance.

===


<!-- .slide: data-state="standard" -->

## Take home messages

- Software are the instructions that tell the hardware (computer) what to do
- Software is a 'living thing'
- We need extra and different techniques for good software management

===

<!-- .slide: data-state="keepintouch" -->


www.esciencecenter.nl

info@esciencecenter.nl

020 - 460 47 70
