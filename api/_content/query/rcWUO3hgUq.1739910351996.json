[{"_path":"/modules/testing/info","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Learning objectives","description":"In this module you will learn to answer the following questions:","type":"info","order":0,"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this module you will learn to answer the following questions:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Appreciate the importance of testing software"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Understand the various benefits of testing"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Understand the types of tests and what info they convey"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get familiar with the idea of continuous integration and its importance"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"local_fs:modules:testing:info.md","_source":"local_fs","_file":"modules/testing/info.md","_stem":"modules/testing/info","_extension":"md","plainText":"---\ntitle: Learning objectives\ntype: info\norder: 0\n---\n\nIn this module you will learn to answer the following questions:\n\n- Appreciate the importance of testing software\n- Understand the various benefits of testing\n- Understand the types of tests and what info they convey\n- Get familiar with the idea of continuous integration and its importance\n"},{"_path":"/modules/testing/slides","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Software Testing","description":"","type":"slides","order":1,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"software-testing"},"children":[{"type":"text","value":"Software Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"what-is-software-testing"},"children":[{"type":"text","value":"What is software testing?"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing is the process of evaluating and verifying that a software and its components meet specified requirements and work as expected. Its primary purpose is to identify defects, errors, flaws, or bugs early in the development process."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As with any other engineering/scientific approach, it's important to check that the expected/required results of your software are accomplished. As such, software testing is analogous to testing lab protocols or (experimental) equipment before publication/putting it on the market."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"=="}]},{"type":"element","tag":"h3","props":{"id":"risks-of-poorly-tested-research-software"},"children":[{"type":"text","value":"Risks of poorly tested (research) software"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/testing-motivation1.png","width":"30%","style":"display:inline;"},"children":[]},{"type":"element","tag":"img","props":{"src":"media/testing-motivation2.png","width":"30%","style":"display:inline;"},"children":[]},{"type":"element","tag":"img","props":{"src":"media/testing-motivation3.png","width":"30%","style":"display:inline;"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" Find the complete articles "},{"type":"element","tag":"a","props":{"href":"https://www.science.org/doi/full/10.1126/science.314.5807.1856","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", "},{"type":"element","tag":"a","props":{"href":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", and "},{"type":"element","tag":"a","props":{"href":"https://www.wired.com/2010/11/1110mars-climate-observer-report/","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":" "}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several examples in which the lack of proper software testings resulted in serious consequences."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The first article from 2006 reports about a software flaw (a plus sign in place of a minus sign) that lead to a retraction of 5 scientific articles."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the second from 2019, researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There is also the case of the Ariane flight V88, an European Space Agency rocket which was destroyed just 40 seconds after its launch due to a software bug; see "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Ariane_flight_V88","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Ariane_flight_V88"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"=="}]},{"type":"element","tag":"h3","props":{"id":"why-test-your-software"},"children":[{"type":"text","value":"Why test your software ?"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ensure continued reliability and reproducibility"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Boost developer confidence"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Detect problems with (updated) dependencies early"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Simplify and manage code complexity"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Confirm correct installation and demonstrate use"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ensuring software reliability, validity, and reproducibility for research software directly influences the reproducibility of the results obtained."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A good test suite gives collaborators and (external) contributors confidence to make modifications without breaking existing functionalities."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As mentioned before, software almost always relies on other software (its dependencies). As the dependencies change or get updated, your use of these depencies may also need to change. Having tests in place will detect such issues as soon as they arise and allow you stay ahead of the curve."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Code that is easy to test is often easier to understand and maintain. By writing good tests, you push yourself to write good code."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Tests can be used as an example or tutorial for (new) users to see how to use the software, or to test that their installation was successful."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"=="}]},{"type":"element","tag":"h3","props":{"id":"the-power-of-automated-testing"},"children":[{"type":"text","value":"The Power of Automated Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software is inherently automatable: use its power to test itself!"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Faster Execution – Runs tests in seconds/minutes vs. hours of manual testing."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Higher Accuracy – Eliminates human error, ensuring consistent results."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Early Detection – Identifies issues when they arise."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Scalability – Handles large test suites without extra effort."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Cost Efficiency – Saves time and resources in the long run."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Developers (and researchers) generally run a number of tests or test scripts manually at certain points in the development process. However, if we think of the problems mentioned in the previous slide, these would often not have been detected by manual testing."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Instead, we would encourage developers to collect those (and more!) tests into a test suite and have them run systematically. Many programming languages have existing tools that helkp you create and run tests suits: "},{"type":"element","tag":"a","props":{"href":"https://docs.pytest.org/","rel":["nofollow"]},"children":[{"type":"text","value":"PyTest"}]},{"type":"text","value":" for Python, "},{"type":"element","tag":"a","props":{"href":"https://testthat.r-lib.org/","rel":["nofollow"]},"children":[{"type":"text","value":"testthat"}]},{"type":"text","value":" for R, "},{"type":"element","tag":"a","props":{"href":"https://junit.org/","rel":["nofollow"]},"children":[{"type":"text","value":"JUnit"}]},{"type":"text","value":" for Java, etc."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"test-types"},"children":[{"type":"text","value":"Test types"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Smoke tests"}]},{"type":"text","value":" verify that the essential functions of the software work."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unit tests"}]},{"type":"text","value":" assess individual components for correctness."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Integration tests"}]},{"type":"text","value":" verify interactions between different parts of the software."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"System tests"}]},{"type":"text","value":" evaluate the complete and integrated software system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Regression tests"}]},{"type":"text","value":" ensure new changes don’t disrupt existing functionality."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Smoke test: A preliminary test to verify that the essential functions of the software work. If a smoke test fails, further testing is halted until the issues are resolved."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unit test: A test that verifies the functionality of an individual unit (e.g., a function, method, or module) in isolation. In unit tests each individual unit of a software is tested separately."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Integration test: A test that checks the interaction between integrated components or modules. Individual units (that are tested in isolation using unit tests) are combined and tested as a group. The goal is to detect faults in how these units work together, especially focusing on data flow, APIs, and dependencies."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"System test: A test that evaluates the complete system as a whole to ensure it meets functional (correct results, no crashes, ...) and non-functional (security, performance, ...) requirements. It checks how different components interact under real-world conditions. It is similar to an integration test but broader in scope."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Regression tests: A test that ensures recent code changes haven't negatively affected existing functionality. This often involves re-running previous test cases to confirm that everything still works as expected."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"=="}]},{"type":"element","tag":"h3","props":{"id":"exercise"},"children":[{"type":"text","value":"Exercise"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"exercise"},"children":[{"type":"text","value":"Identify the test types during the production of a pen."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"continuous-integration-and-deployment-cicd"},"children":[{"type":"text","value":"Continuous Integration and Deployment (CI/CD)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CI/CD is \"next level\" automation for your software project!"}]},{"type":"element","tag":"img","props":{"src":"https://blog.cloudhm.co.th/wp-content/uploads/2021/03/ci-cd.png","width":"50%"},"children":[]},{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" Image source: https://blog.cloudhm.co.th/ci-cd/ "}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes, often several times a day, into a shared remote repository. After every integration, a working version of the project is built and the software's test suite is run automatically, making it possible to identify defects, errors, flaws, or bugs introduced by changes early in the development process. This helps keep the code up-to-date and reduces the chances of major issues when combining everyone's work."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous deployment (CD) is the practice of automatically deploying every working version of the project that passes the automated testing phase to its end-users."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"take-home-messages"},"children":[{"type":"text","value":"Take home messages"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Automated software testing is key for quality, reliability, and reproducibility"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unit tests verify individual components, integration tests check component interactions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CI/CD streamlines development and enhances deployment efficiency"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.esciencecenter.nl","rel":["nofollow"]},"children":[{"type":"text","value":"www.esciencecenter.nl"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"mailto:info@esciencecenter.nl"},"children":[{"type":"text","value":"info@esciencecenter.nl"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"020 - 460 47 70"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"software-testing","depth":2,"text":"Software Testing","children":[{"id":"what-is-software-testing","depth":3,"text":"What is software testing?"},{"id":"risks-of-poorly-tested-research-software","depth":3,"text":"Risks of poorly tested (research) software"},{"id":"why-test-your-software","depth":3,"text":"Why test your software ?"},{"id":"the-power-of-automated-testing","depth":3,"text":"The Power of Automated Testing"},{"id":"test-types","depth":3,"text":"Test types"},{"id":"exercise","depth":3,"text":"Exercise"},{"id":"continuous-integration-and-deployment-cicd","depth":3,"text":"Continuous Integration and Deployment (CI/CD)"}]},{"id":"take-home-messages","depth":2,"text":"Take home messages"}]}},"_type":"markdown","_id":"local_fs:modules:testing:slides.md","_source":"local_fs","_file":"modules/testing/slides.md","_stem":"modules/testing/slides","_extension":"md","plainText":"---\ntitle: Software Testing\ntype: slides\norder: 1\n---\n\n<!-- .slide: data-state=\"title\" -->\n\n## Software Testing\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### What is software testing?\n\n> Software testing is the process of evaluating and verifying that a software and its components meet specified requirements and work as expected. Its primary purpose is to identify defects, errors, flaws, or bugs early in the development process.\n\nNote:\n\nAs with any other engineering/scientific approach, it's important to check that the expected/required results of your software are accomplished. As such, software testing is analogous to testing lab protocols or (experimental) equipment before publication/putting it on the market.\n\n==\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Risks of poorly tested (research) software\n\n<center>\n<img src=\"media/testing-motivation1.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation2.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation3.png\" width=\"30%\" style=\"display:inline;\">\n</center>\n\n\n<small> Find the complete articles [here](https://www.science.org/doi/full/10.1126/science.314.5807.1856), [here](https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/), and [here](https://www.wired.com/2010/11/1110mars-climate-observer-report/) </small>\n\nNote:\n\nThere are several examples in which the lack of proper software testings resulted in serious consequences.\n\nThe first article from 2006 reports about a software flaw (a plus sign in place of a minus sign) that lead to a retraction of 5 scientific articles.\n\nIn the second from 2019, researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies.\n\nThe loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake.\n\nThere is also the case of the Ariane flight V88, an European Space Agency rocket which was destroyed just 40 seconds after its launch due to a software bug; see https://en.wikipedia.org/wiki/Ariane_flight_V88.\n\n==\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Why test your software ?\n\n- Ensure continued reliability and reproducibility\n- Boost developer confidence\n- Detect problems with (updated) dependencies early\n- Simplify and manage code complexity\n- Confirm correct installation and demonstrate use\n\nNote:\n\n- Ensuring software reliability, validity, and reproducibility for research software directly influences the reproducibility of the results obtained.\n- A good test suite gives collaborators and (external) contributors confidence to make modifications without breaking existing functionalities.\n- As mentioned before, software almost always relies on other software (its dependencies). As the dependencies change or get updated, your use of these depencies may also need to change. Having tests in place will detect such issues as soon as they arise and allow you stay ahead of the curve.\n- Code that is easy to test is often easier to understand and maintain. By writing good tests, you push yourself to write good code.\n- Tests can be used as an example or tutorial for (new) users to see how to use the software, or to test that their installation was successful.\n\n==\n\n<!-- .slide: data-state=\"standard\" -->\n\n### The Power of Automated Testing\n\nSoftware is inherently automatable: use its power to test itself!\n\n- Faster Execution – Runs tests in seconds/minutes vs. hours of manual testing.\n- Higher Accuracy – Eliminates human error, ensuring consistent results.\n- Early Detection – Identifies issues when they arise.\n- Scalability – Handles large test suites without extra effort.\n- Cost Efficiency – Saves time and resources in the long run.\n\nNote:\n\nDevelopers (and researchers) generally run a number of tests or test scripts manually at certain points in the development process. However, if we think of the problems mentioned in the previous slide, these would often not have been detected by manual testing.\n\nInstead, we would encourage developers to collect those (and more!) tests into a test suite and have them run systematically. Many programming languages have existing tools that helkp you create and run tests suits: [PyTest](https://docs.pytest.org/) for Python, [testthat](https://testthat.r-lib.org/) for R, [JUnit](https://junit.org/) for Java, etc.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Test types\n\n- **Smoke tests** verify that the essential functions of the software work.\n- **Unit tests** assess individual components for correctness.\n- **Integration tests** verify interactions between different parts of the software.\n- **System tests** evaluate the complete and integrated software system.\n- **Regression tests** ensure new changes don’t disrupt existing functionality.\n\nNote:\n\n- Smoke test: A preliminary test to verify that the essential functions of the software work. If a smoke test fails, further testing is halted until the issues are resolved.\n- Unit test: A test that verifies the functionality of an individual unit (e.g., a function, method, or module) in isolation. In unit tests each individual unit of a software is tested separately.\n- Integration test: A test that checks the interaction between integrated components or modules. Individual units (that are tested in isolation using unit tests) are combined and tested as a group. The goal is to detect faults in how these units work together, especially focusing on data flow, APIs, and dependencies.\n- System test: A test that evaluates the complete system as a whole to ensure it meets functional (correct results, no crashes, ...) and non-functional (security, performance, ...) requirements. It checks how different components interact under real-world conditions. It is similar to an integration test but broader in scope.\n- Regression tests: A test that ensures recent code changes haven't negatively affected existing functionality. This often involves re-running previous test cases to confirm that everything still works as expected.\n\n==\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Exercise\n\n[Identify the test types during the production of a pen.](exercise)\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Continuous Integration and Deployment (CI/CD)\n\nCI/CD is \"next level\" automation for your software project!\n\n<img src=\"https://blog.cloudhm.co.th/wp-content/uploads/2021/03/ci-cd.png\" width=\"50%\">\n<small> Image source: https://blog.cloudhm.co.th/ci-cd/ </small>\n\nNote:\n\nContinuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes, often several times a day, into a shared remote repository. After every integration, a working version of the project is built and the software's test suite is run automatically, making it possible to identify defects, errors, flaws, or bugs introduced by changes early in the development process. This helps keep the code up-to-date and reduces the chances of major issues when combining everyone's work.\n\nContinuous deployment (CD) is the practice of automatically deploying every working version of the project that passes the automated testing phase to its end-users.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Take home messages\n\n- Automated software testing is key for quality, reliability, and reproducibility\n- Unit tests verify individual components, integration tests check component interactions\n- CI/CD streamlines development and enhances deployment efficiency\n\n===\n\n<!-- .slide: data-state=\"keepintouch\" -->\n\n\nwww.esciencecenter.nl\n\ninfo@esciencecenter.nl\n\n020 - 460 47 70\n"},{"_path":"/modules/testing/software-testing","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Software Testing","description":"","type":"reading","order":2,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"software-testing-5-minutes"},"children":[{"type":"text","value":"Software Testing (5 minutes)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing is the process of evaluating and verifying that software and its components meet specified requirements and function as expected. This critical step in the software development lifecycle ensures that the final product is reliable, functional, and free of significant defects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The primary goal of software testing is to identify defects, errors, flaws, or bugs early in the development process. By detecting issues early, developers can address them before the software is released, reducing the risk of costly fixes and enhancing overall quality. Software testing can be conducted manually, where a human tester actively uses the software, performing various actions and observing the results to detect any anomalies or unexpected behavior. Alternatively, automated testing utilizes test scripts or tools to execute tests automatically, which is efficient for repetitive tasks and can quickly cover a wide range of test scenarios."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Untested software can be likened to uncalibrated experimental devices. Just as uncalibrated instruments may provide inaccurate data and lead to erroneous conclusions, untested software can contain hidden defects that compromise its reliability and performance, potentially leading to critical failures in real-world applications; see optional section below."}]},{"type":"element","tag":"h3","props":{"id":"what-can-tests-help-you-do"},"children":[{"type":"text","value":"What can tests help you do?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tests play a crucial role in ensuring the reliability, validity, and reproducibility of your software's results. They help users easily verify that they have correctly installed your software, often providing examples of how to use it effectively. Tests also enable other developers to contribute to your software and make modifications with confidence, knowing that nothing is breaking."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Additionally, tests preserve expected functionality by ensuring that new changes do not introduce unintended side effects. They manage complexity by encouraging code that is easier to test, which in turn makes it easier to understand and maintain."}]},{"type":"element","tag":"h3","props":{"id":"types-of-testing"},"children":[{"type":"text","value":"Types of Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several types of tests used in software development, each serving a specific purpose to ensure the quality and functionality of the software."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Smoke Tests"}]},{"type":"text","value":": Also known as \"verification testing\", \"confidence testing\" or \"sanity testing\", smoke tests are a preliminary type of testing that checks the basic functionality of the software. They are often used to determine if a new build is stable enough to proceed with more detailed testing. Smoke tests quickly identify major issues that could prevent the software from functioning at a basic level."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unit Tests"}]},{"type":"text","value":": These tests focus on individual functions or components of the software, testing them one at a time. Unit tests are designed to validate that each function performs as expected in isolation, ensuring that the smallest parts of the codebase work correctly."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Integration Tests"}]},{"type":"text","value":": These tests evaluate how different parts of the software work together. Integration tests are crucial for identifying issues that arise when components interact, ensuring that the integrated parts function seamlessly as a whole."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"System Tests"}]},{"type":"text","value":": These tests involve evaluating the entire software system running in an environment that simulates real-world conditions. System tests aim to verify that the software meets all specified requirements and performs well under expected usage scenarios."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Regression Tests"}]},{"type":"text","value":": These tests are used to ensure that recent code changes have not adversely affected existing functionality. By checking that the software produces the same results as before the changes, regression tests help maintain stability and prevent the reintroduction of previously fixed bugs."}]}]},{"type":"element","tag":"h2","props":{"id":"examples-of-untested-research-software-40-minutes-optional"},"children":[{"type":"text","value":"Examples of untested research software (40 minutes, optional)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several examples in which the lack of proper software testings resulted in serious consequences. Here are a few interesting cases:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Therac-25","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Therac-25"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(1980) A tragic example of software bugs leading to loss of life, the Therac-25 radiation therapy machine had a flaw in its software, which resulted in patients receiving lethal doses of radiation."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Ariane_flight_V88","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Ariane_flight_V88"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(1996) This European Space Agency rocket was destroyed just 40 seconds after its launch due to a software bug."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.wired.com/2010/11/1110mars-climate-observer-report/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.wired.com/2010/11/1110mars-climate-observer-report/"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(1999) The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Year_2000_problem","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Year_2000_problem"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2000) The Y2K bug was a widespread computer flaw that was expected to cause chaos as the date changed from December 31, 1999, to January 1, 2000."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.science.org/doi/full/10.1126/science.314.5807.1856","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.science.org/doi/full/10.1126/science.314.5807.1856"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2006) A software flaw (a plus sign which should have been a minus) lead to a retraction of 5 scientific articles."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Knight_Capital_Group","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Knight_Capital_Group"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2013) Knight Capital, a financial services firm, lost around $440 million within less than an hour due to a software glitch in its trading algorithms."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2018-2019) Software issues with the Boeing 737 MAX's Maneuvering Characteristics Augmentation System (MCAS) were implicated in two fatal crashes"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/","rel":["nofollow"]},"children":[{"type":"text","value":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2019) Researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"software-testing-5-minutes","depth":2,"text":"Software Testing (5 minutes)","children":[{"id":"what-can-tests-help-you-do","depth":3,"text":"What can tests help you do?"},{"id":"types-of-testing","depth":3,"text":"Types of Testing"}]},{"id":"examples-of-untested-research-software-40-minutes-optional","depth":2,"text":"Examples of untested research software (40 minutes, optional)"}]}},"_type":"markdown","_id":"local_fs:modules:testing:software-testing.md","_source":"local_fs","_file":"modules/testing/software-testing.md","_stem":"modules/testing/software-testing","_extension":"md","plainText":"---\ntitle: Software Testing\ntype: reading\norder: 2\n---\n\n## Software Testing (5 minutes)\n\nSoftware testing is the process of evaluating and verifying that software and its components meet specified requirements and function as expected. This critical step in the software development lifecycle ensures that the final product is reliable, functional, and free of significant defects.\n\nThe primary goal of software testing is to identify defects, errors, flaws, or bugs early in the development process. By detecting issues early, developers can address them before the software is released, reducing the risk of costly fixes and enhancing overall quality. Software testing can be conducted manually, where a human tester actively uses the software, performing various actions and observing the results to detect any anomalies or unexpected behavior. Alternatively, automated testing utilizes test scripts or tools to execute tests automatically, which is efficient for repetitive tasks and can quickly cover a wide range of test scenarios.\n\nUntested software can be likened to uncalibrated experimental devices. Just as uncalibrated instruments may provide inaccurate data and lead to erroneous conclusions, untested software can contain hidden defects that compromise its reliability and performance, potentially leading to critical failures in real-world applications; see optional section below.\n\n### What can tests help you do?\n\nTests play a crucial role in ensuring the reliability, validity, and reproducibility of your software's results. They help users easily verify that they have correctly installed your software, often providing examples of how to use it effectively. Tests also enable other developers to contribute to your software and make modifications with confidence, knowing that nothing is breaking.\n\nAdditionally, tests preserve expected functionality by ensuring that new changes do not introduce unintended side effects. They manage complexity by encouraging code that is easier to test, which in turn makes it easier to understand and maintain.\n\n### Types of Testing\n\nThere are several types of tests used in software development, each serving a specific purpose to ensure the quality and functionality of the software.\n\n- **Smoke Tests**: Also known as \"verification testing\", \"confidence testing\" or \"sanity testing\", smoke tests are a preliminary type of testing that checks the basic functionality of the software. They are often used to determine if a new build is stable enough to proceed with more detailed testing. Smoke tests quickly identify major issues that could prevent the software from functioning at a basic level.\n\n- **Unit Tests**: These tests focus on individual functions or components of the software, testing them one at a time. Unit tests are designed to validate that each function performs as expected in isolation, ensuring that the smallest parts of the codebase work correctly.\n\n- **Integration Tests**: These tests evaluate how different parts of the software work together. Integration tests are crucial for identifying issues that arise when components interact, ensuring that the integrated parts function seamlessly as a whole.\n\n- **System Tests**: These tests involve evaluating the entire software system running in an environment that simulates real-world conditions. System tests aim to verify that the software meets all specified requirements and performs well under expected usage scenarios.\n\n- **Regression Tests**: These tests are used to ensure that recent code changes have not adversely affected existing functionality. By checking that the software produces the same results as before the changes, regression tests help maintain stability and prevent the reintroduction of previously fixed bugs.\n\n## Examples of untested research software (40 minutes, optional)\n\nThere are several examples in which the lack of proper software testings resulted in serious consequences. Here are a few interesting cases:\n\n- https://en.wikipedia.org/wiki/Therac-25\n  - (1980) A tragic example of software bugs leading to loss of life, the Therac-25 radiation therapy machine had a flaw in its software, which resulted in patients receiving lethal doses of radiation.\n\n- https://en.wikipedia.org/wiki/Ariane_flight_V88\n  - (1996) This European Space Agency rocket was destroyed just 40 seconds after its launch due to a software bug.\n\n- https://www.wired.com/2010/11/1110mars-climate-observer-report/\n  - (1999) The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake.\n\n- https://en.wikipedia.org/wiki/Year_2000_problem\n  - (2000) The Y2K bug was a widespread computer flaw that was expected to cause chaos as the date changed from December 31, 1999, to January 1, 2000.\n\n- https://www.science.org/doi/full/10.1126/science.314.5807.1856\n  - (2006) A software flaw (a plus sign which should have been a minus) lead to a retraction of 5 scientific articles.\n\n- https://en.wikipedia.org/wiki/Knight_Capital_Group\n  - (2013) Knight Capital, a financial services firm, lost around $440 million within less than an hour due to a software glitch in its trading algorithms.\n\n- https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings\n  - (2018-2019) Software issues with the Boeing 737 MAX's Maneuvering Characteristics Augmentation System (MCAS) were implicated in two fatal crashes\n\n- https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/\n  - (2019) Researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."},{"_path":"/modules/testing/ci-cd","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"CI/CD","description":"","type":"reading","order":3,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"continuous-integration-ci-2-minutes"},"children":[{"type":"text","value":"Continuous Integration (CI) (2 minutes)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes into a shared remote repository, often several times a day. After each integration, a working version of the project is built, and the software's test suite is run automatically. This process allows for the early identification of defects, errors, flaws, or bugs introduced by changes, helping to maintain code quality and reduce the chances of major issues when combining everyone's work."}]},{"type":"element","tag":"h3","props":{"id":"importance-of-ci"},"children":[{"type":"text","value":"Importance of CI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CI offers several key benefits:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Early Bug Detection"}]},{"type":"text","value":": By identifying bugs early, CI minimizes their impact and makes them easier to fix."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Synchronization"}]},{"type":"text","value":": Keeps project contributors up to date with each other’s work, allowing them to benefit from new features as soon as possible."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Encouragement to Write Tests"}]},{"type":"text","value":": Promotes the practice of writing tests, ensuring better code quality."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Test Automation"}]},{"type":"text","value":": Automates the process of running tests, saving time and effort."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Frequent Testing"}]},{"type":"text","value":": Ensures that tests are run frequently, maintaining continuous validation of the software's functionality."}]}]},{"type":"element","tag":"h2","props":{"id":"continuous-deployment-cd-1-minute"},"children":[{"type":"text","value":"Continuous Deployment (CD) (1 minute)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Deployment (CD) is an extension of the CI practice that automates the release of software updates to users. This is done for every change that passes all stages of the development pipeline, including automated tests. CD ensures that the software is always in a releasable state and that new features, improvements, and bug fixes are delivered to users quickly and consistently."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Together, CI and CD form a powerful combination that enhances the efficiency, reliability, and speed of the software development process."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"continuous-integration-ci-2-minutes","depth":2,"text":"Continuous Integration (CI) (2 minutes)","children":[{"id":"importance-of-ci","depth":3,"text":"Importance of CI"}]},{"id":"continuous-deployment-cd-1-minute","depth":2,"text":"Continuous Deployment (CD) (1 minute)"}]}},"_type":"markdown","_id":"local_fs:modules:testing:ci-cd.md","_source":"local_fs","_file":"modules/testing/ci-cd.md","_stem":"modules/testing/ci-cd","_extension":"md","plainText":"---\ntitle: CI/CD\ntype: reading\norder: 3\n---\n\n## Continuous Integration (CI) (2 minutes)\nContinuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes into a shared remote repository, often several times a day. After each integration, a working version of the project is built, and the software's test suite is run automatically. This process allows for the early identification of defects, errors, flaws, or bugs introduced by changes, helping to maintain code quality and reduce the chances of major issues when combining everyone's work.\n\n### Importance of CI\nCI offers several key benefits:\n\n- **Early Bug Detection**: By identifying bugs early, CI minimizes their impact and makes them easier to fix.\n- **Synchronization**: Keeps project contributors up to date with each other’s work, allowing them to benefit from new features as soon as possible.\n- **Encouragement to Write Tests**: Promotes the practice of writing tests, ensuring better code quality.\n- **Test Automation**: Automates the process of running tests, saving time and effort.\n- **Frequent Testing**: Ensures that tests are run frequently, maintaining continuous validation of the software's functionality.\n\n## Continuous Deployment (CD) (1 minute)\nContinuous Deployment (CD) is an extension of the CI practice that automates the release of software updates to users. This is done for every change that passes all stages of the development pipeline, including automated tests. CD ensures that the software is always in a releasable state and that new features, improvements, and bug fixes are delivered to users quickly and consistently.\n\nTogether, CI and CD form a powerful combination that enhances the efficiency, reliability, and speed of the software development process.\n"},{"_path":"/modules/testing/exercise","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Testing Exercise","description":"","type":"exercise","order":4,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"exercise-2"},"children":[{"type":"text","value":"Exercise 2"}]},{"type":"element","tag":"h2","props":{"id":"identify-the-test-types-in-this-story"},"children":[{"type":"text","value":"Identify the test types in this story:"}]},{"type":"element","tag":"big","props":{},"children":[{"type":"text","value":"\nDuring the process of manufacturing a ballpoint pen, we see smoke coming out of one of our machines, so we halt production immediately, put out the fire, and check why it caught fire in the first place before continuing.\n"},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We can now start production. The cap, the body, the tail, the ink cartridge, and the ballpoint are produced separately and we check the quality of each component before assembly. Next we check that the cap and tail fit on the body and the ink cartridge fits inside. When everything is put together, we ensure that it writes properly and doesn't leak."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"big","props":{},"children":[{"type":"text","value":"In the future, we plan to supply different colors of ink and will re-run these tests for each new colored pen.\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"identify-the-test-types-in-this-story","depth":2,"text":"Identify the test types in this story:"}]}},"_type":"markdown","_id":"local_fs:modules:testing:exercise.md","_source":"local_fs","_file":"modules/testing/exercise.md","_stem":"modules/testing/exercise","_extension":"md","plainText":"---\ntitle: Testing Exercise\ntype: exercise\norder: 4\n---\n\n# Exercise 2\n\n## Identify the test types in this story:\n\n<big>\nDuring the process of manufacturing a ballpoint pen, we see smoke coming out of one of our machines, so we halt production immediately, put out the fire, and check why it caught fire in the first place before continuing.\n\nWe can now start production. The cap, the body, the tail, the ink cartridge, and the ballpoint are produced separately and we check the quality of each component before assembly. Next we check that the cap and tail fit on the body and the ink cartridge fits inside. When everything is put together, we ensure that it writes properly and doesn't leak.\n\nIn the future, we plan to supply different colors of ink and will re-run these tests for each new colored pen.\n</big>\n"},{"_path":"/modules/testing/self-test","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Self test","description":"","type":"exercise","order":5,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"question-a-what-is-software-testing"},"children":[{"type":"text","value":"Question A: What is software testing?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A method for evaluating a software's compatibility with different operating systems."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The process of releasing updates and patches for software."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The process of verifying and validating that a software meets the required specifications and works as intended."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A step in the software lifecycle focused on community engagement and feedback."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The practice of documenting software functionalities."}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"question-b-why-is-software-testing-important"},"children":[{"type":"text","value":"Question B: Why is software testing important?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To build and maintain the community's trust by demonstrating commitment to quality."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To identify and fix bugs, ensure the software meets required standards, and assess its reliability and reproducibility."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To design the software's user interface and graphics."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To accelerate the overall software development process."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To facilitate easier collaboration among developers."}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"question-c-which-best-describes-continuous-integration-and-its-benefits-for-this-project"},"children":[{"type":"text","value":"Question C: Which best describes Continuous Integration and its benefits for this project?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Continuous Integration is a practice where team members work in isolation to ensure their code is perfect before integrating it once at the end of the project, helping to avoid conflicts and errors."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Continuous Integration involves the use of specialized software to automatically translate code into multiple programming languages, making it more versatile and reducing workload."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Continuous Integration is a development practice where team members frequently integrate their work, often several times a day, to detect and fix integration issues early, thereby improving collaboration and code quality."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Continuous Integration is a method where team members manually review each other's code at the end of each day, ensuring that the code meets quality standards and is ready for client presentation."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Continuous Integration refers to the continuous updating of software to incorporate user feedback and new features, ensuring the software evolves to meet user needs."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"answers:"}]},{"type":"text","value":"\nA: 3\nB: The most obvious answer is 2, but in fact all answers except 3 are correct\nC: 3\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"question-a-what-is-software-testing","depth":2,"text":"Question A: What is software testing?"},{"id":"question-b-why-is-software-testing-important","depth":2,"text":"Question B: Why is software testing important?"},{"id":"question-c-which-best-describes-continuous-integration-and-its-benefits-for-this-project","depth":2,"text":"Question C: Which best describes Continuous Integration and its benefits for this project?"}]}},"_type":"markdown","_id":"local_fs:modules:testing:self-test.md","_source":"local_fs","_file":"modules/testing/self-test.md","_stem":"modules/testing/self-test","_extension":"md","plainText":"---\ntitle: Self test\ntype: exercise\norder: 5\n---\n\n## Question A: What is software testing?\n\n1. A method for evaluating a software's compatibility with different operating systems.\n2. The process of releasing updates and patches for software.\n3. The process of verifying and validating that a software meets the required specifications and works as intended.\n4. A step in the software lifecycle focused on community engagement and feedback.\n5. The practice of documenting software functionalities.\n\n---\n\n## Question B: Why is software testing important?\n\n1. To build and maintain the community's trust by demonstrating commitment to quality.\n2. To identify and fix bugs, ensure the software meets required standards, and assess its reliability and reproducibility.\n3. To design the software's user interface and graphics.\n4. To accelerate the overall software development process.\n5. To facilitate easier collaboration among developers.\n\n---\n\n## Question C: Which best describes Continuous Integration and its benefits for this project?\n\n1. Continuous Integration is a practice where team members work in isolation to ensure their code is perfect before integrating it once at the end of the project, helping to avoid conflicts and errors.\n2. Continuous Integration involves the use of specialized software to automatically translate code into multiple programming languages, making it more versatile and reducing workload.\n3. Continuous Integration is a development practice where team members frequently integrate their work, often several times a day, to detect and fix integration issues early, thereby improving collaboration and code quality.\n4. Continuous Integration is a method where team members manually review each other's code at the end of each day, ensuring that the code meets quality standards and is ready for client presentation.\n5. Continuous Integration refers to the continuous updating of software to incorporate user feedback and new features, ensuring the software evolves to meet user needs.\n\n<small> **answers:** \nA: 3\nB: The most obvious answer is 2, but in fact all answers except 3 are correct\nC: 3\n</small>\n"},{"_path":"/modules/testing/reading","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Reading material","description":"","type":"reading","order":7,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"reading-material"},"children":[{"type":"text","value":"Reading material"}]},{"type":"element","tag":"h2","props":{"id":"testing"},"children":[{"type":"text","value":"Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Follow the links below to read more about software testing."}]},{"type":"element","tag":"h3","props":{"id":"the-turing-way"},"children":[{"type":"text","value":"The Turing Way"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in the Turing Way about "},{"type":"element","tag":"a","props":{"href":"https://the-turing-way.netlify.app/reproducible-research/testing","rel":["nofollow"]},"children":[{"type":"text","value":"Code Testing"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"code-refinery"},"children":[{"type":"text","value":"Code Refinery"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in CodeRefinery about "},{"type":"element","tag":"a","props":{"href":"https://coderefinery.github.io/testing/motivation/","rel":["nofollow"]},"children":[{"type":"text","value":"Automated testing"}]}]},{"type":"element","tag":"h3","props":{"id":"ibm"},"children":[{"type":"text","value":"IBM"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Link to an "},{"type":"element","tag":"a","props":{"href":"https://www.ibm.com/topics/software-testing","rel":["nofollow"]},"children":[{"type":"text","value":"IBM article"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"arxiv"},"children":[{"type":"text","value":"arXiv"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read this interesting article about "},{"type":"element","tag":"a","props":{"href":"https://arxiv.org/abs/2205.15982","rel":["nofollow"]},"children":[{"type":"text","value":"Testing Research Software"}]}]},{"type":"element","tag":"h2","props":{"id":"cicd"},"children":[{"type":"text","value":"CI/CD"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Follow the links below to read more about CI/CD."}]},{"type":"element","tag":"h3","props":{"id":"the-turing-way-1"},"children":[{"type":"text","value":"The Turing Way"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in the Turing Way about "},{"type":"element","tag":"a","props":{"href":"https://the-turing-way.netlify.app/reproducible-research/ci","rel":["nofollow"]},"children":[{"type":"text","value":"Continuous Integration"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"code-refinery-1"},"children":[{"type":"text","value":"Code Refinery"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in CodeRefinery about "},{"type":"element","tag":"a","props":{"href":"https://coderefinery.github.io/testing/continuous-integration/","rel":["nofollow"]},"children":[{"type":"text","value":"Continuous integration"}]}]},{"type":"element","tag":"h3","props":{"id":"bytebytego-newsletter"},"children":[{"type":"text","value":"ByteByteGo Newsletter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in ByteByteGo newsletter about "},{"type":"element","tag":"a","props":{"href":"https://blog.bytebytego.com/p/a-crash-course-in-cicd","rel":["nofollow"]},"children":[{"type":"text","value":"A Crash Course in CI/CD"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"testing","depth":2,"text":"Testing","children":[{"id":"the-turing-way","depth":3,"text":"The Turing Way"},{"id":"code-refinery","depth":3,"text":"Code Refinery"},{"id":"ibm","depth":3,"text":"IBM"},{"id":"arxiv","depth":3,"text":"arXiv"}]},{"id":"cicd","depth":2,"text":"CI/CD","children":[{"id":"the-turing-way-1","depth":3,"text":"The Turing Way"},{"id":"code-refinery-1","depth":3,"text":"Code Refinery"},{"id":"bytebytego-newsletter","depth":3,"text":"ByteByteGo Newsletter"}]}]}},"_type":"markdown","_id":"local_fs:modules:testing:reading.md","_source":"local_fs","_file":"modules/testing/reading.md","_stem":"modules/testing/reading","_extension":"md","plainText":"---\ntitle: Reading material\ntype: reading\norder: 7\n---\n\n# Reading material\n\n## Testing\nFollow the links below to read more about software testing.\n\n### The Turing Way\nRead in the Turing Way about [Code Testing](https://the-turing-way.netlify.app/reproducible-research/testing).\n\n### Code Refinery\nRead in CodeRefinery about [Automated testing](https://coderefinery.github.io/testing/motivation/)\n\n### IBM\nLink to an [IBM article](https://www.ibm.com/topics/software-testing).\n\n### arXiv\nRead this interesting article about [Testing Research Software](https://arxiv.org/abs/2205.15982)\n\n## CI/CD\nFollow the links below to read more about CI/CD.\n\n### The Turing Way\nRead in the Turing Way about [Continuous Integration](https://the-turing-way.netlify.app/reproducible-research/ci).\n\n### Code Refinery\nRead in CodeRefinery about [Continuous integration](https://coderefinery.github.io/testing/continuous-integration/)\n\n### ByteByteGo Newsletter\nRead in ByteByteGo newsletter about [A Crash Course in CI/CD](https://blog.bytebytego.com/p/a-crash-course-in-cicd)"}]