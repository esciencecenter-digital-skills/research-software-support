{"_path":"/modules/testing/slides","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Software Testing","description":"","type":"slides","order":1,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"software-testing"},"children":[{"type":"text","value":"Software Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"what-is-software-testing"},"children":[{"type":"text","value":"What is software testing?"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“Software testing is the process of evaluating and verifying that a software product or application does what it’s supposed to do. The benefits of good testing include preventing bugs and improving performance.”"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.ibm.com/topics/software-testing","rel":["nofollow"]},"children":[{"type":"text","value":"From IBM Featured Topics"}]},{"type":"text","value":" "}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"What is software testing?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing is the process of evaluating and verifying that a software and its components meet specified requirements and work as expected. Its primary purpose is to identify defects, errors, flaws, or bugs early in the development process."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing can be done manually, where a human actively uses the software to observe for defects, or automatically, where test scripts or tools are used to execute tests."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Untested software can be compared to uncalibrated experimental devices."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"risks-of-untested-research-software"},"children":[{"type":"text","value":"Risks of untested research software"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/testing-motivation1.png","width":"30%","style":"display:inline;"},"children":[]},{"type":"element","tag":"img","props":{"src":"media/testing-motivation2.png","width":"30%","style":"display:inline;"},"children":[]},{"type":"element","tag":"img","props":{"src":"media/testing-motivation3.png","width":"30%","style":"display:inline;"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" Find the complete articles "},{"type":"element","tag":"a","props":{"href":"https://www.science.org/doi/full/10.1126/science.314.5807.1856","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", "},{"type":"element","tag":"a","props":{"href":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", and "},{"type":"element","tag":"a","props":{"href":"https://www.wired.com/2010/11/1110mars-climate-observer-report/","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":" "}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several examples in which the lack of proper software testings resulted in serious consequences."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The first article from 2006 reports about a software flaw (a plus sign in place of a minus sign) that lead to a retraction of 5 scientific articles."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the second from 2019, researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There is also the case of the Ariane flight V88, an European Space Agency rocket which was destroyed just 40 seconds after its launch due to a software bug; see "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Ariane_flight_V88","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Ariane_flight_V88"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"why-testing-your-software"},"children":[{"type":"text","value":"Why testing your software ?"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ensure software reliability, validity, and reproducibility."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Confirm correct installation and demonstrate use."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Boost developer confidence for contributions and modifications."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Maintain expected software functionality."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Simplify and manage code complexity."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Why testing your software is so crucial?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Specifically for research software, tests are vital for ensuring the reliability, validity, and reproducibility of your scientific results."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"They help users by enabling them confirm that the software is installed correctly, providing usage examples."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tests also help other developers modify and contribute to your software. A good test suite gives collaborators confidence to make modifications without breaking existing functionalities.\nThey preserve the expected functionality of the software."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Manage complexity: Code that is easy to test is often easier to understand and maintain."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"types-of-testing"},"children":[{"type":"text","value":"Types of testing"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unit tests"}]},{"type":"text","value":": Assess individual components for correctness."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Integration tests"}]},{"type":"text","value":": Verify interactions between different parts of the software."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"System tests"}]},{"type":"text","value":": Evaluate the complete and integrated software system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Regression tests"}]},{"type":"text","value":": Ensure new changes don’t disrupt existing functionality."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several types of software testing, each of which with its own purpose."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In unit tests each individual unit of a software is tested separately. The purpose is to ensure that each component of the software works as expected."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Integration tests are a level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The complete, integrated system is checked via the so-called system tests. The purpose here is to evaluate whether the software as a whole gives the correct outputs for given inputs."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, regression tests check for unexpected side-effects in existing features after changes."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"continuous-integration-and-continuous-deployment-cicd"},"children":[{"type":"text","value":"Continuous Integration and Continuous Deployment (CI/CD)"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/cicd_scheme.png","width":"50%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes, often several times a day, into a shared remote repository. After every integration, a working version of the project is build and the software's test suite is run automatically, making it possible to identify defects, errors, flaws, or bugs introduced by changes early in the development process. This helps keep the code up-to-date and reduces the chances of major issues when combining everyone's work."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous deployment (CD) is the next step after CI in the CI/CD pipeline shown in the figure. CD is the practice of automatically deploying every working version of the project that passes the automated testing phase to its end-users."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"benefits-of-continuous-integration"},"children":[{"type":"text","value":"Benefits of continuous integration"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/benefits_of_ci.png","width":"70%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"take-home-messages"},"children":[{"type":"text","value":"Take home messages"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Software testing is key for quality, reliability, and reproducibility"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unit tests verify individual components, integration tests check component interactions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CI/CD streamline development and enhance deployment efficiency."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.esciencecenter.nl","rel":["nofollow"]},"children":[{"type":"text","value":"www.esciencecenter.nl"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"mailto:info@esciencecenter.nl"},"children":[{"type":"text","value":"info@esciencecenter.nl"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"software-testing","depth":2,"text":"Software Testing"},{"id":"what-is-software-testing","depth":2,"text":"What is software testing?"},{"id":"risks-of-untested-research-software","depth":2,"text":"Risks of untested research software"},{"id":"why-testing-your-software","depth":2,"text":"Why testing your software ?"},{"id":"types-of-testing","depth":2,"text":"Types of testing"},{"id":"continuous-integration-and-continuous-deployment-cicd","depth":2,"text":"Continuous Integration and Continuous Deployment (CI/CD)"},{"id":"benefits-of-continuous-integration","depth":2,"text":"Benefits of continuous integration"},{"id":"take-home-messages","depth":2,"text":"Take home messages"}]}},"_type":"markdown","_id":"local_fs:modules:testing:slides.md","_source":"local_fs","_file":"modules/testing/slides.md","_extension":"md","plainText":"---\ntitle: Software Testing\ntype: slides\norder: 1\n---\n\n<!-- .slide: data-state=\"title\" -->\n\n## Software Testing\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## What is software testing?\n\n> “Software testing is the process of evaluating and verifying that a software product or application does what it’s supposed to do. The benefits of good testing include preventing bugs and improving performance.”\n\n<small>[From IBM Featured Topics](https://www.ibm.com/topics/software-testing) </small>\n\nNote:\n\nWhat is software testing?\n\nSoftware testing is the process of evaluating and verifying that a software and its components meet specified requirements and work as expected. Its primary purpose is to identify defects, errors, flaws, or bugs early in the development process.\n\nSoftware testing can be done manually, where a human actively uses the software to observe for defects, or automatically, where test scripts or tools are used to execute tests.\n\nUntested software can be compared to uncalibrated experimental devices.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Risks of untested research software\n\n<center>\n<img src=\"media/testing-motivation1.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation2.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation3.png\" width=\"30%\" style=\"display:inline;\">\n</center>\n\n\n<small> Find the complete articles [here](https://www.science.org/doi/full/10.1126/science.314.5807.1856), [here](https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/), and [here](https://www.wired.com/2010/11/1110mars-climate-observer-report/) </small>\n\nNote:\n\nThere are several examples in which the lack of proper software testings resulted in serious consequences.\n\nThe first article from 2006 reports about a software flaw (a plus sign in place of a minus sign) that lead to a retraction of 5 scientific articles.\n\nIn the second from 2019, researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies.\n\nThe loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake.\n\nThere is also the case of the Ariane flight V88, an European Space Agency rocket which was destroyed just 40 seconds after its launch due to a software bug; see https://en.wikipedia.org/wiki/Ariane_flight_V88.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Why testing your software ?\n\n- Ensure software reliability, validity, and reproducibility.\n- Confirm correct installation and demonstrate use.\n- Boost developer confidence for contributions and modifications.\n- Maintain expected software functionality.\n- Simplify and manage code complexity.\n\nNote:\n\nWhy testing your software is so crucial?\n\nSpecifically for research software, tests are vital for ensuring the reliability, validity, and reproducibility of your scientific results.\n\nThey help users by enabling them confirm that the software is installed correctly, providing usage examples.\n\nTests also help other developers modify and contribute to your software. A good test suite gives collaborators confidence to make modifications without breaking existing functionalities.\nThey preserve the expected functionality of the software.\n\nManage complexity: Code that is easy to test is often easier to understand and maintain.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Types of testing\n\n- **Unit tests**: Assess individual components for correctness.\n- **Integration tests**: Verify interactions between different parts of the software.\n- **System tests**: Evaluate the complete and integrated software system.\n- **Regression tests**: Ensure new changes don’t disrupt existing functionality.\n\nNote:\n\nThere are several types of software testing, each of which with its own purpose.\n\nIn unit tests each individual unit of a software is tested separately. The purpose is to ensure that each component of the software works as expected.\n\nIntegration tests are a level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units.\n\nThe complete, integrated system is checked via the so-called system tests. The purpose here is to evaluate whether the software as a whole gives the correct outputs for given inputs.\n\nFinally, regression tests check for unexpected side-effects in existing features after changes.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Continuous Integration and Continuous Deployment (CI/CD)\n\n<center>\n<img src=\"media/cicd_scheme.png\" width=\"50%\">\n</center>\n\nNote:\n\nContinuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes, often several times a day, into a shared remote repository. After every integration, a working version of the project is build and the software's test suite is run automatically, making it possible to identify defects, errors, flaws, or bugs introduced by changes early in the development process. This helps keep the code up-to-date and reduces the chances of major issues when combining everyone's work.\n\nContinuous deployment (CD) is the next step after CI in the CI/CD pipeline shown in the figure. CD is the practice of automatically deploying every working version of the project that passes the automated testing phase to its end-users.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Benefits of continuous integration\n\n<center>\n<img src=\"media/benefits_of_ci.png\" width=\"70%\">\n</center>\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Take home messages\n\n- Software testing is key for quality, reliability, and reproducibility\n- Unit tests verify individual components, integration tests check component interactions\n- CI/CD streamline development and enhance deployment efficiency.\n\n===\n\n<!-- .slide: data-state=\"keepintouch\" -->\n\n\nwww.esciencecenter.nl\n\ninfo@esciencecenter.nl\n"}