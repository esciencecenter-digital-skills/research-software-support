[{"_path":"/modules/documentation/slides_documentation","_dir":"documentation","_draft":false,"_partial":false,"_locale":"","title":"Documentation","description":"===","type":"slides","order":1,"author":"Luisa Orozco, Barbara Vreede, Jaro Camphuijsen, Carlos Martinez, Max Paulus, Robin Richardson","_type":"markdown","_id":"local_fs:modules:documentation:slides_documentation.md","_source":"local_fs","_file":"modules/documentation/slides_documentation.md","_extension":"md","plainText":"---\ntitle: Documentation\ntype: slides\norder: 1\nauthor: Luisa Orozco, Barbara Vreede, Jaro Camphuijsen, Carlos Martinez, Max Paulus, Robin Richardson\n---\n\n<!-- .slide: data-state=\"title\" -->\n\n# Documentation\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## What is documentation?\n\n- Provides context for your work\n- Allows your collaborators and future you to understand what has been done and why\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Why document software?\n\nMake your software reusable:\n \n- A user should be able to run your software in the same way as you do now \n- A user should be able to install your software\n- A contributor should be able to add or improve code\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Documentation types\n\nUser documentation\n- Purpose: What does the software do?\n- How can it be used: provide examples\n\nDeveloper documentation\n- How can your software be modified or extended?\n\nDeployment documentation\n- Hardware and software requirements\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Documentation formats\n\n<!-- add visual with documentation format with increasing complexity -->\n\n- In-code: intended for contributors (comments, docstrings, ...)\n- README: simple text file, first thing that users/collaborators see\n- Websites, Wikis \n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## A good README file\n\n+ README file is first thing a user/collaborator sees\n+ What should be included in README files?\n<ul>\n  <li contenteditable=\"true\">...</li>\n  <li contenteditable=\"true\">...</li>\n  <li contenteditable=\"true\">...</li>\n  <li contenteditable=\"true\">...</li>\n  <li contenteditable=\"true\">...</li>\n  <li contenteditable=\"true\">...</li>\n  <li contenteditable=\"true\">...</li>\n</ul>\n\n\nNote:\n+ A descriptive project title\n+ Motivation (why the project exists) and basics\n+ Installation / How to setup\n+ Copy-pasteable quick start code example\n+ Usage reference (if not elsewhere)\n+ Recommended citation if someone uses it\n+ Other related tools (\"see also\")\n+ Contact information for the developer(s)\n+ License information\n+ Contributing guidelines\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Why write in-code documentation?\n\nIn-code documentation:\n\n+ Makes code more understandable\n+ Explains decisions we made\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## When **not** to use in-code documentation?\n\n+ When the code is self-explanatory\n+ To replace good variable/function names\n+ To replace version control\n+ To keep old (zombie) code around\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Readable code vs commented code\n\n```python=\n# convert from degrees celsius to fahrenheit\ndef convert(d):\n    return d * 5 / 9 + 32\n```\nvs\n```python=\ndef celsius_to_fahrenheit(degrees):\n    return degrees * 5 / 9 + 32\n```\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## What makes a good comment?\n\n**Comment A**\n\n<pre data-id=\"code-animation\"><code style=\"overflow: hidden;\" data-trim class=\"python\">\n# Now we check if temperature is larger than -50:\nif temperature > -50:\n    print('do something')\n</code></pre>\n\n**Comment B**\n\n<pre data-id=\"code-animation\"><code style=\"overflow: hidden;\" data-trim class=\"python\">\n# We regard temperatures below -50 degrees as measurement errors\nif temperature > -50:\n    print('do something')\n</code></pre>\n\nHow are these different? Which one do you prefer?\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Docstrings: a special kind of comment\n\n```python=\ndef celsius_to_fahrenheit(degrees):\n  \"\"\"Convert degrees Celsius to degrees Fahrenheit.\"\"\"\n  return degrees * 5 / 9 + 32\n```\n\nWhy is this OK?\n\nNote:\nDocstrings can be used to generate user documentation.\nThey are accessible outside the code.\nThey follow a standardized syntax.\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## In-code commenting: key points\n\n+ Explicit, descriptive naming already provides important documentation.\n+ Comments should describe the why for your code, not the what.\n+ Writing docstrings is an easy way to write documentation while you code, as they are accessible outside the code itself.\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## User/API documentation\n\n+ What if a README file is not enough?\n+ How do I easily create user documentation?\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Tools\n\n+ **Sphinx** (documentation generator)\n  - creates nicely-formatted HTML pages out of .md or .rst files\n  - programming language independent\n+ **Github pages** (deploy your documentation)\n  - set up inside your GitHub repository\n  - automatically deploys your Sphinx-generated documentation\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Take-home message\n\n+ Depending on the purpose and state of the project documentation needs to meet different criteria.\n+ Documentation can take different shapes:\n  + Readable code\n  + In-code comments\n  + Docstrings\n  + README files\n  + Tutorials/notebooks\n+ Documentation is a vital part of a project, and should be kept and created alongside the corresponding code.\n"},{"_path":"/modules/fairsoftware/exercise1","_dir":"fairsoftware","_draft":false,"_partial":false,"_locale":"","title":"What is FAIR?","description":"","type":"exercise","order":2,"_type":"markdown","_id":"local_fs:modules:fairsoftware:exercise1.md","_source":"local_fs","_file":"modules/fairsoftware/exercise1.md","_extension":"md","plainText":"---\ntitle: What is FAIR?\ntype: exercise\norder: 2\n---\n\n## Exercise: What is FAIR?\n\n### FAIR principles (15 minutes)\n\nThe FAIR principles are:\n\n- **F**indable\n- **A**ccessible\n- **I**nteroperable\n- **R**eusable\n\nThey were originally introduced in [this paper by Wilkinson et al.](https://doi.org/10.1038/sdata.2016.18).\nThis paper is a good starting point to learn more about FAIR, but if you are already familiar with the concept, a quick skim of the paper should do.\nThe most important take-away from this particular paper is the point that FAIR, while originally a data-specific concept, was designed with other digital objects in mind as well.\n\n### FAIR software (10 minutes)\n\nTo extend the FAIR principles to software, the [FAIR 4 Research Software working group](https://force11.org/groups/fair-4-research-software-fair4rs-working-group/) was formed.\nTheir paper [Introducing the FAIR principles for research software](https://doi.org/10.1038/s41597-022-01710-x) describes in more practical terms how FAIR can be applied to software.\n\n#### You should now be able to\n\n- Understand the different facets of FAIR\n- Be aware of the machine-actionable nature of FAIR\n- Get a feeling for additional challenges that software poses to FAIR\n\n### FAIR software (20 minutes, optional)\n\nWhile the intepretation of the FAIR4RS working group has been the dominant set of principles since its publication, it was not the first attempt to apply FAIR to software.\n[This paper by Anna Lena Lamprecht et al.](https://doi.org/10.3233/ds-190026) was published a few years earlier, and also described an extension of the FAIR principles for software.\nThe paper is a more elaborate in its descriptions of software, the different aspects of software, and how they are or are not addressed by FAIR.\nIt is a good read if you want to get a deeper understanding of software and its relation to the FAIR principles.\n\n### Discussion\n\n- What are the differences between FAIR principles for data and software?\n- What challenges do you see in making software FAIR?\n- Why is FAIR software important?"}]