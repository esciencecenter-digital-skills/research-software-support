[{"_path":"/modules/distributing/info","_dir":"distributing","_draft":false,"_partial":false,"_locale":"","title":"Learning objectives","description":"In this module you will learn to answer the following questions:","type":"info","order":0,"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this module you will learn to answer the following questions:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"What is software distribution and what aspects of it are important for research software?"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"What kinds of software exist and how are they best distributed?"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"What should you keep in mind when people ask for help on software distribution?"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"local_fs:modules:distributing:info.md","_source":"local_fs","_file":"modules/distributing/info.md","_stem":"modules/distributing/info","_extension":"md","plainText":"---\ntitle: Learning objectives\ntype: info\norder: 0\n---\n\nIn this module you will learn to answer the following questions:\n\n- What is software distribution and what aspects of it are important for research software?\n- What kinds of software exist and how are they best distributed?\n- What should you keep in mind when people ask for help on software distribution?\n\n"},{"_path":"/modules/distributing/slides-distributing","_dir":"distributing","_draft":false,"_partial":false,"_locale":"","title":"Distributing Software","description":"===","type":"slides","order":1,"author":"Jaro Camphuijsen, Lourens Veen","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"distributing-software"},"children":[{"type":"text","value":"Distributing Software"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"why-distribute"},"children":[{"type":"text","value":"Why distribute?"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For reproducibility/transparency of research"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For developers that want to reuse parts of your software/methods"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For users that want to use your software"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nThere are many potential reasons for distributing your software. In science, these three\nscenarios are the most common. Note that users and developers can include yourself!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"kinds-of-software"},"children":[{"type":"text","value":"Kinds of software"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Script, program, notebook, package, library, image, container, it's confusing!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Let's clear that up first"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nSoftware can seem very confusing, because there are many different terms that are used\nto describe various kinds of software, and they're often used sloppily as well. So let's\nstart with explaining a bit how software is put together, and what all these terms mean."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"functions-or-procedures"},"children":[{"type":"text","value":"Functions (or Procedures)"}]},{"type":"element","tag":"div","props":{"style":"width: 40%; float: left; margin-top: 3%"},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ordered list of instructions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Like a recipe"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Can refer to other recipes"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Closed box"}]}]}]},{"type":"element","tag":"div","props":{"style":"width: 60%; float: right; margin-top: 3%"},"children":[{"type":"element","tag":"pre","props":{"style":"font-size: 70%; text-align: left"},"children":[{"type":"text","value":"def minmax(list_of_things):\n    sorted_things = sorted(list_of_things)\n    smallest = sorted_things[0]\n    largest = sorted_things[-1]\n    return smallest, largest\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nTo start, let's simplify everything way down and look at a basic component of software,\nthe function. (There's more to it, but this is all we need here and gives a good idea.)\nA function, or procedure which is really a better term but not what most people use\nanymore, is a list of instructions, like a recipe."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To make lasagna, you use sheets of dough, Béchamel sauce, and tomato sauce, and stack\nthem up in alternating layers before cooking everything in the oven. Of course tomato\nsauce does not grow on trees, so you'll need a sub-recipe to make that, and it's the\nsame with functions: they call other functions."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Like with cooking, where you might get some ready-made pasta or sauce, the functions\ncalled from a function can be made by someone else. Your laptop has tens or hundreds of\nthousands of functions in it to do everything it does."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"scripts-and-notebooks"},"children":[{"type":"text","value":"Scripts and Notebooks"}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: left; margin-top: 3%"},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Single file with function(s)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Sit at the top of a pyramid"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Use libraries"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Run interactively"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"User handles errors"}]}]}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: right; margin-top: 0%"},"children":[{"type":"element","tag":"img","props":{"src":"/modules/distributing/media/scripts_notebooks.png","width":"100%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nA script is a small bit of software, usually a single file with one or a few functions\nin it. A notebook is a script that is run in a special environment, like Jupyter, which\nshows the script as a document with blocks of code and results (e.g. graphs) embedded in\nit."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Scripts and notebooks are run interactively by a user, who can see the code and handles\nany errors, if they occur. The functions called by the functions in a script are usually\nnot in the script itself, but come from libraries."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"libraries"},"children":[{"type":"text","value":"Libraries"}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: left; margin-top: 5%"},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Lower levels of the pyramid"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ready-made functionality"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Have an interface"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Handle errors itself"}]}]}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: right; margin-top: 0%"},"children":[{"type":"element","tag":"img","props":{"src":"/modules/distributing/media/scripts_notebooks.png","width":"100%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nLibraries are collections of functions intended for use by others, either other\nlibraries, or scripts, or even people. They contain ready-made functionality organised\naround a topic. For example there are plotting libraries that can make different kinds\nof graphs, or libraries that can solve particular kinds of equations."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Libraries have an interface or API, which consists of functions that the user is\nsupposed to call. The library will probably have some internal functions as well.\nLibraries need to handle any errors if they occur, either by working around the problem\nor by reporting it to the user in a well-defined way."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Designing APIs and handling errors is hard, so making a good library is not so easy, but\nlibraries are very reusable."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"programs"},"children":[{"type":"text","value":"Programs"}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: left; margin-top: 3%"},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"At the top, or including all"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Bigger than a script"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"End product, with user interface"}]}]}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: right; margin-top: 3%"},"children":[{"type":"element","tag":"img","props":{"src":"/modules/distributing/media/programs.png","width":"100%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nProgram is a very generic term. A script is a small program, and the borderline isn't\nvery clear. A program can do things on its own, so a library is not a program. Programs\noften include all the libraries that they use, but you can also say that program X\ndepends on library Y. A program is not meant for programmers, but for end users, with\nwhich it communicates through some kind of user interface, be it graphical or using text\nor on the command line."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"packages"},"children":[{"type":"text","value":"Packages"}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: left; margin-top: 3%"},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A file containing a collection of software"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Intended for distribution"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Usually holds a library or a program"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Has metadata"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Listed in a package index"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Installed using a package manager"}]}]}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: right; margin-top: 6%"},"children":[{"type":"element","tag":"img","props":{"src":"/modules/distributing/media/packages.png","width":"100%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nPackages are often used to distribute software. A package is an archive file (e.g. a\nZIP file) that contains software, usually a library or a program. There is also metadata\nthat describes, among other things, licenses and authors and other packages containing software that is\nneeded by this one."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Packages are usually uploaded to a package index, an online store of packages where\nusers can find them and download them, e.g. PyPI or CRAN. Finding, downloading and\ninstalling is done using a tool called a package manager, like pip or conda."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Especially older programming languages may not have a standard package index or package\nmanager, e.g. C++ and Fortran."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"images-and-containers"},"children":[{"type":"text","value":"Images and containers"}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: left; margin-top: 3%"},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A file containing a collection of software"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Everything, including the OS"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Cannot be combined"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Can be run like a program, as a container"}]}]}]},{"type":"element","tag":"div","props":{"style":"width: 50%; float: right; margin-top: 3%"},"children":[{"type":"element","tag":"img","props":{"src":"/modules/distributing/media/images_containers.png","width":"100%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nA virtual machine image or container image is a file containing a collection of\nsoftware, like a package. However, an image contains absolutely everything needed,\nincluding (most of) the operating system. If you have an image, then you can run the\nprogram inside it on your computer. This will create a kind of virtual computer inside\nyour computer (that's called a Virtual Machine or a Container) inside which the software\nruns. Containers cannot be combined and you can't call them from a script, so they're\nonly useful for programs, not for libraries, and the user needs special software to be\nable to run the program."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"scenario-1-review-reproduce"},"children":[{"type":"text","value":"Scenario 1: Review & reproduce"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"You have a script"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The script uses some libraries"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"You want others to see and run it"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"distributing-scriptsnotebooks"},"children":[{"type":"text","value":"Distributing scripts/notebooks"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make script/notebook available for download"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make environment file, e.g. requirements.txt, environment.yml"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"User uses a package manager to create environment"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"User runs the script/notebook"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Optional: use an image (mostly long-term archival)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nIn this case, you have a script or a notebook, and also an environment (e.g. using Conda\nor virtualenv) with the libraries you use installed in it. This environment is really\njust a folder on your computer with the libraries in it, and some machinery that makes\nit so that when the script calls a function that is in a library, the library will be\nfound and the function run."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So, you need to share your script or notebook of course, but the user will also need a\nsimilar environment to run it, otherwise those library functions are missing. You can\n(and should!) facilitate that by making an environment file that describes all the\npackages containing the libraries that you're using. If you then make that available,\nthe user can create a similar environment on their computer and run your script."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software that manages these environments, like Conda and pip/virtualenv, can make these\nenvironment files for you, and also read one and create an environment by downloading\nall the needed packages from the Internet, so this is not too difficult."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another option is to use an image, but 1) they're very big, 2) they require special\nsoftware, and 3) they're much more work to create. They do have the advantage that they\nwork without an Internet, or in the future when all that old stuff is no longer online."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"scenario-2-a-reusable-method"},"children":[{"type":"text","value":"Scenario 2: A reusable method"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"You have created a new method"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Should be somewhat generic"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To be used by programmers"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Needs a library!"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nScientists sometimes develop new methods for calculating something, for example\nacoustics in a room. They will likely have a script that calculates things for their\npaper, and that script can be shared as in Scenario 1, but it would also be nice if\npeople could use their method for calculating acoustics in all sorts of scenarios, in\ncombination with other calculations."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this case, what's really needed is a library. As mentioned before, making libraries\nisn't that easy, so they may need some help from a Research Software Engineer to design\na good interface. Another option, and often a better one actually, is to contribute to\nan existing widely used library. That will give your code more exposure, and may get you\nsome help from its maintainers as well, in the form of reviews."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"distributing-libraries"},"children":[{"type":"text","value":"Distributing libraries"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Make a package containing the library"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Add metadata with dependencies"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Upload the package to a repository"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nThe best way to distribute a library is by making a package for it, if there is a\nsuitable packaging system available. Most modern programming languages have one, e.g.\nPyPI and pip for Python, or CRAN and install.packages() for R, or Cargo for Rust."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So your steps here are to find the right packaging system based on the programming\nlanguage the library is written in, then creating a package for that system (there is\nusually a manual/tutorial available), and uploading the package to the repository so\nthat users can use their package manager to install it. Make sure to list all the\ndependencies in the metadata!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For languages like Fortran or C++ that don't have a standard package manager, you could\ntry Conda, or make packages for an operating system-specific packaging system like\nAPT/DPKG (Debian/Ubuntu Linux), DNF/RPM (Red Hat Linux), HomeBrew or macPorts (macOS) or\neven EasyBuild, Spack or Nix (on High-Performance Computing)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"scenario-3-a-whole-application"},"children":[{"type":"text","value":"Scenario 3: A whole application"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Not so common in science"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"You have created a program"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To be used by end users"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nScientists don't often make whole applications with user interfaces that anyone can just\npick up and use. That's a lot of work, and you don't get credit for it in science.\nNevertheless there are examples of this, e.g. MaxEnt in ecology, and it could happen. In\nthis case, what you have is a program."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"distributing-programs"},"children":[{"type":"text","value":"Distributing programs"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"In an app store!"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As an installer?"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As a package?"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As an image?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nThere are a few options for distributing a program. Packaging systems can be used,\nespecially if the program is intended for use by programmers, or by more knowledgeable\nusers. An App Store is basically a packaging system for applications, and that would be\na good option too if available."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another option is to make an installer. That's a single file that is a working program,\nlike a package, but it is also itself a program that when run will install your program\nonto the user's system. If you've installed software on Windows then you may have seen\none, although they've mostly been replaced by app stores and may cause the operating\nsystem to warn about suspicious software."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, you could make an image here, but as before, it would be very large, and it\nwould require special software on the user's computer, so in the here and now it's not a\ngood option. It would be more resistant to changes in the operating system that break\nthe program, because it includes the old version of the operating system. And then\nagain, running an old operating system is a security risk."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"updating-software"},"children":[{"type":"text","value":"Updating software"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Can't we just put it online and be done?"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For scripts, you probably can"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Libraries and programs need maintenance"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nScripts are built on top of libraries, which sit on top of an operating system, which\nsits on top of hardware, and all that stuff is constantly changing. Furthermore, people change and expect to use software in different ways over\ntime, and that also needs to be taken into account."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For example, the LimePy library in the AMUSE astrophysics software uses a function in\nthe SciPy library that does not exist anymore. The old version of SciPy it was written\nfor was designed for an old version of Python, which is no longer supported and\nshouldn't be used anymore, for security reasons. Also, a script using LimePy may use\nother libraries that require a newer SciPy, and you can't install multiple versions of\nthe same thing at the same time, so you won't be able to run that script anymore."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Because of this, all software needs to be updated from time to time in order to continue\nto work. This is tricky in science, which works in terms of projects that are finished\nand then replaced by something else. For scripts, it's probably not so important because\npeople can still read the script to see what you did, and update it if they see the\nneed."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For libraries and programs, it's a different story, because those are used over a longer\nperiod, and for libraries other things get built on top of them, and we'd like all that\nto continue to work."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"versioning"},"children":[{"type":"text","value":"Versioning"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Use "},{"type":"element","tag":"a","props":{"href":"https://semver.org/","rel":["nofollow"]},"children":[{"type":"text","value":"Semantic Versioning"}]},{"type":"text","value":" for libraries (X.Y.Z)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Less important for applications"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"note:\nFor libraries, it's important that you communicate about changes with programmers using\nyour library. If the changes affect your interface, then they will have to modify their\nsoftware to work with your new version. This is sometimes necessary and sometimes a good\nidea, as long as it doesn't happen too often. You do need to communicate it clearly\nhowever."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A good way to do that is to use Semantic Versioning. This uses X.Y.Z versions, and from\nversion 1.0.0 promises that everything built on top of the library will continue to work\nas long as the first number remains the same. The second number is changed to mark\nadding new functions, and the third number is incremented if the new version only fixes\nbugs."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h3","props":{"id":"summary"},"children":[{"type":"text","value":"Summary"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Script/notebook: publish with environment"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Library: package and upload"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Program: app store, package, installer"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.esciencecenter.nl","rel":["nofollow"]},"children":[{"type":"text","value":"www.esciencecenter.nl"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"mailto:info@esciencecenter.nl"},"children":[{"type":"text","value":"info@esciencecenter.nl"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"020 - 460 47 70"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"why-distribute","depth":2,"text":"Why distribute?"},{"id":"kinds-of-software","depth":2,"text":"Kinds of software","children":[{"id":"functions-or-procedures","depth":3,"text":"Functions (or Procedures)"},{"id":"scripts-and-notebooks","depth":3,"text":"Scripts and Notebooks"},{"id":"libraries","depth":3,"text":"Libraries"},{"id":"programs","depth":3,"text":"Programs"},{"id":"packages","depth":3,"text":"Packages"},{"id":"images-and-containers","depth":3,"text":"Images and containers"},{"id":"scenario-1-review-reproduce","depth":3,"text":"Scenario 1: Review & reproduce"},{"id":"distributing-scriptsnotebooks","depth":3,"text":"Distributing scripts/notebooks"},{"id":"scenario-2-a-reusable-method","depth":3,"text":"Scenario 2: A reusable method"},{"id":"distributing-libraries","depth":3,"text":"Distributing libraries"},{"id":"scenario-3-a-whole-application","depth":3,"text":"Scenario 3: A whole application"},{"id":"distributing-programs","depth":3,"text":"Distributing programs"},{"id":"updating-software","depth":3,"text":"Updating software"},{"id":"versioning","depth":3,"text":"Versioning"},{"id":"summary","depth":3,"text":"Summary"}]}]}},"_type":"markdown","_id":"local_fs:modules:distributing:slides-distributing.md","_source":"local_fs","_file":"modules/distributing/slides-distributing.md","_stem":"modules/distributing/slides-distributing","_extension":"md","plainText":"---\ntitle: Distributing Software\ntype: slides\norder: 1\nauthor: Jaro Camphuijsen, Lourens Veen\n---\n\n<!-- .slide: data-state=\"title blue_overlay yellow_flag yellow_strip purple_half_circle_bottom purple_blob right_e_top\" -->\n\n# Distributing Software\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Why distribute?\n\n1. For reproducibility/transparency of research\n2. For developers that want to reuse parts of your software/methods\n3. For users that want to use your software\n\nnote:\nThere are many potential reasons for distributing your software. In science, these three\nscenarios are the most common. Note that users and developers can include yourself!\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Kinds of software\n\n\nScript, program, notebook, package, library, image, container, it's confusing!\n\nLet's clear that up first\n\nnote:\nSoftware can seem very confusing, because there are many different terms that are used\nto describe various kinds of software, and they're often used sloppily as well. So let's\nstart with explaining a bit how software is put together, and what all these terms mean.\n\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Functions (or Procedures)\n\n<div style=\"width: 40%; float: left; margin-top: 3%\">\n\n- Ordered list of instructions\n- Like a recipe\n- Can refer to other recipes\n- Closed box\n\n</div>\n\n<div style=\"width: 60%; float: right; margin-top: 3%\">\n\n<pre style=\"font-size: 70%; text-align: left\">\ndef minmax(list_of_things):\n    sorted_things = sorted(list_of_things)\n    smallest = sorted_things[0]\n    largest = sorted_things[-1]\n    return smallest, largest\n</pre>\n\n</div>\n\nnote:\nTo start, let's simplify everything way down and look at a basic component of software,\nthe function. (There's more to it, but this is all we need here and gives a good idea.)\nA function, or procedure which is really a better term but not what most people use\nanymore, is a list of instructions, like a recipe.\n\nTo make lasagna, you use sheets of dough, Béchamel sauce, and tomato sauce, and stack\nthem up in alternating layers before cooking everything in the oven. Of course tomato\nsauce does not grow on trees, so you'll need a sub-recipe to make that, and it's the\nsame with functions: they call other functions.\n\nLike with cooking, where you might get some ready-made pasta or sauce, the functions\ncalled from a function can be made by someone else. Your laptop has tens or hundreds of\nthousands of functions in it to do everything it does.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Scripts and Notebooks\n\n<div style=\"width: 50%; float: left; margin-top: 3%\">\n\n- Single file with function(s)\n- Sit at the top of a pyramid\n- Use libraries\n- Run interactively\n- User handles errors\n\n</div>\n\n<div style=\"width: 50%; float: right; margin-top: 0%\">\n\n<img src=\"media/scripts_notebooks.png\" width=\"100%\">\n\n</div>\n\n\nnote:\nA script is a small bit of software, usually a single file with one or a few functions\nin it. A notebook is a script that is run in a special environment, like Jupyter, which\nshows the script as a document with blocks of code and results (e.g. graphs) embedded in\nit.\n\nScripts and notebooks are run interactively by a user, who can see the code and handles\nany errors, if they occur. The functions called by the functions in a script are usually\nnot in the script itself, but come from libraries.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Libraries\n\n<div style=\"width: 50%; float: left; margin-top: 5%\">\n\n- Lower levels of the pyramid\n- Ready-made functionality\n- Have an interface\n- Handle errors itself\n\n</div>\n\n<div style=\"width: 50%; float: right; margin-top: 0%\">\n\n<img src=\"media/scripts_notebooks.png\" width=\"100%\">\n\n</div>\n\n\nnote:\nLibraries are collections of functions intended for use by others, either other\nlibraries, or scripts, or even people. They contain ready-made functionality organised\naround a topic. For example there are plotting libraries that can make different kinds\nof graphs, or libraries that can solve particular kinds of equations.\n\nLibraries have an interface or API, which consists of functions that the user is\nsupposed to call. The library will probably have some internal functions as well.\nLibraries need to handle any errors if they occur, either by working around the problem\nor by reporting it to the user in a well-defined way.\n\nDesigning APIs and handling errors is hard, so making a good library is not so easy, but\nlibraries are very reusable.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Programs\n\n<div style=\"width: 50%; float: left; margin-top: 3%\">\n\n- At the top, or including all\n- Bigger than a script\n- End product, with user interface\n\n</div>\n\n<div style=\"width: 50%; float: right; margin-top: 3%\">\n\n<img src=\"media/programs.png\" width=\"100%\">\n\n</div>\n\nnote:\nProgram is a very generic term. A script is a small program, and the borderline isn't\nvery clear. A program can do things on its own, so a library is not a program. Programs\noften include all the libraries that they use, but you can also say that program X\ndepends on library Y. A program is not meant for programmers, but for end users, with\nwhich it communicates through some kind of user interface, be it graphical or using text\nor on the command line.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Packages\n\n<div style=\"width: 50%; float: left; margin-top: 3%\">\n\n- A file containing a collection of software\n- Intended for distribution\n- Usually holds a library or a program\n- Has metadata\n- Listed in a package index\n- Installed using a package manager\n\n</div>\n\n<div style=\"width: 50%; float: right; margin-top: 6%\">\n\n<img src=\"media/packages.png\" width=\"100%\">\n\n</div>\n\n\nnote:\nPackages are often used to distribute software. A package is an archive file (e.g. a\nZIP file) that contains software, usually a library or a program. There is also metadata\nthat describes, among other things, licenses and authors and other packages containing software that is\nneeded by this one.\n\nPackages are usually uploaded to a package index, an online store of packages where\nusers can find them and download them, e.g. PyPI or CRAN. Finding, downloading and\ninstalling is done using a tool called a package manager, like pip or conda.\n\nEspecially older programming languages may not have a standard package index or package\nmanager, e.g. C++ and Fortran.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Images and containers\n\n<div style=\"width: 50%; float: left; margin-top: 3%\">\n\n- A file containing a collection of software\n- Everything, including the OS\n- Cannot be combined\n- Can be run like a program, as a container\n\n</div>\n\n<div style=\"width: 50%; float: right; margin-top: 3%\">\n\n<img src=\"media/images_containers.png\" width=\"100%\">\n\n</div>\n\nnote:\nA virtual machine image or container image is a file containing a collection of\nsoftware, like a package. However, an image contains absolutely everything needed,\nincluding (most of) the operating system. If you have an image, then you can run the\nprogram inside it on your computer. This will create a kind of virtual computer inside\nyour computer (that's called a Virtual Machine or a Container) inside which the software\nruns. Containers cannot be combined and you can't call them from a script, so they're\nonly useful for programs, not for libraries, and the user needs special software to be\nable to run the program.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Scenario 1: Review & reproduce\n\n- You have a script\n- The script uses some libraries\n- You want others to see and run it\n\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Distributing scripts/notebooks\n\n- Make script/notebook available for download\n- Make environment file, e.g. requirements.txt, environment.yml\n- User uses a package manager to create environment\n- User runs the script/notebook\n- Optional: use an image (mostly long-term archival)\n\nnote:\nIn this case, you have a script or a notebook, and also an environment (e.g. using Conda\nor virtualenv) with the libraries you use installed in it. This environment is really\njust a folder on your computer with the libraries in it, and some machinery that makes\nit so that when the script calls a function that is in a library, the library will be\nfound and the function run.\n\nSo, you need to share your script or notebook of course, but the user will also need a\nsimilar environment to run it, otherwise those library functions are missing. You can\n(and should!) facilitate that by making an environment file that describes all the\npackages containing the libraries that you're using. If you then make that available,\nthe user can create a similar environment on their computer and run your script.\n\nSoftware that manages these environments, like Conda and pip/virtualenv, can make these\nenvironment files for you, and also read one and create an environment by downloading\nall the needed packages from the Internet, so this is not too difficult.\n\nAnother option is to use an image, but 1) they're very big, 2) they require special\nsoftware, and 3) they're much more work to create. They do have the advantage that they\nwork without an Internet, or in the future when all that old stuff is no longer online.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Scenario 2: A reusable method\n\n- You have created a new method\n- Should be somewhat generic\n- To be used by programmers\n- Needs a library!\n\nnote:\nScientists sometimes develop new methods for calculating something, for example\nacoustics in a room. They will likely have a script that calculates things for their\npaper, and that script can be shared as in Scenario 1, but it would also be nice if\npeople could use their method for calculating acoustics in all sorts of scenarios, in\ncombination with other calculations.\n\nIn this case, what's really needed is a library. As mentioned before, making libraries\nisn't that easy, so they may need some help from a Research Software Engineer to design\na good interface. Another option, and often a better one actually, is to contribute to\nan existing widely used library. That will give your code more exposure, and may get you\nsome help from its maintainers as well, in the form of reviews.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Distributing libraries\n\n- Make a package containing the library\n- Add metadata with dependencies\n- Upload the package to a repository\n\nnote:\nThe best way to distribute a library is by making a package for it, if there is a\nsuitable packaging system available. Most modern programming languages have one, e.g.\nPyPI and pip for Python, or CRAN and install.packages() for R, or Cargo for Rust.\n\nSo your steps here are to find the right packaging system based on the programming\nlanguage the library is written in, then creating a package for that system (there is\nusually a manual/tutorial available), and uploading the package to the repository so\nthat users can use their package manager to install it. Make sure to list all the\ndependencies in the metadata!\n\nFor languages like Fortran or C++ that don't have a standard package manager, you could\ntry Conda, or make packages for an operating system-specific packaging system like\nAPT/DPKG (Debian/Ubuntu Linux), DNF/RPM (Red Hat Linux), HomeBrew or macPorts (macOS) or\neven EasyBuild, Spack or Nix (on High-Performance Computing)\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Scenario 3: A whole application\n\n- Not so common in science\n- You have created a program\n- To be used by end users\n\nnote:\nScientists don't often make whole applications with user interfaces that anyone can just\npick up and use. That's a lot of work, and you don't get credit for it in science.\nNevertheless there are examples of this, e.g. MaxEnt in ecology, and it could happen. In\nthis case, what you have is a program.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Distributing programs\n\n- In an app store!\n- As an installer?\n- As a package?\n- As an image?\n\nnote:\nThere are a few options for distributing a program. Packaging systems can be used,\nespecially if the program is intended for use by programmers, or by more knowledgeable\nusers. An App Store is basically a packaging system for applications, and that would be\na good option too if available.\n\nAnother option is to make an installer. That's a single file that is a working program,\nlike a package, but it is also itself a program that when run will install your program\nonto the user's system. If you've installed software on Windows then you may have seen\none, although they've mostly been replaced by app stores and may cause the operating\nsystem to warn about suspicious software.\n\nFinally, you could make an image here, but as before, it would be very large, and it\nwould require special software on the user's computer, so in the here and now it's not a\ngood option. It would be more resistant to changes in the operating system that break\nthe program, because it includes the old version of the operating system. And then\nagain, running an old operating system is a security risk.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Updating software\n\n- Can't we just put it online and be done?\n- For scripts, you probably can\n- Libraries and programs need maintenance\n\n\nnote:\nScripts are built on top of libraries, which sit on top of an operating system, which\nsits on top of hardware, and all that stuff is constantly changing. Furthermore, people change and expect to use software in different ways over\ntime, and that also needs to be taken into account.\n\nFor example, the LimePy library in the AMUSE astrophysics software uses a function in\nthe SciPy library that does not exist anymore. The old version of SciPy it was written\nfor was designed for an old version of Python, which is no longer supported and\nshouldn't be used anymore, for security reasons. Also, a script using LimePy may use\nother libraries that require a newer SciPy, and you can't install multiple versions of\nthe same thing at the same time, so you won't be able to run that script anymore.\n\nBecause of this, all software needs to be updated from time to time in order to continue\nto work. This is tricky in science, which works in terms of projects that are finished\nand then replaced by something else. For scripts, it's probably not so important because\npeople can still read the script to see what you did, and update it if they see the\nneed.\n\nFor libraries and programs, it's a different story, because those are used over a longer\nperiod, and for libraries other things get built on top of them, and we'd like all that\nto continue to work.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Versioning\n\n- Use [Semantic Versioning](https://semver.org/) for libraries (X.Y.Z)\n- Less important for applications\n\nnote:\nFor libraries, it's important that you communicate about changes with programmers using\nyour library. If the changes affect your interface, then they will have to modify their\nsoftware to work with your new version. This is sometimes necessary and sometimes a good\nidea, as long as it doesn't happen too often. You do need to communicate it clearly\nhowever.\n\nA good way to do that is to use Semantic Versioning. This uses X.Y.Z versions, and from\nversion 1.0.0 promises that everything built on top of the library will continue to work\nas long as the first number remains the same. The second number is changed to mark\nadding new functions, and the third number is incremented if the new version only fixes\nbugs.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n### Summary\n\n- Script/notebook: publish with environment\n- Library: package and upload\n- Program: app store, package, installer\n\n===\n\n<!-- .slide: data-state=\"keepintouch\" -->\n\n\n[www.esciencecenter.nl](https://www.esciencecenter.nl)\n\ninfo@esciencecenter.nl\n\n020 - 460 47 70\n"},{"_path":"/modules/distributing/exercise-distributing","_dir":"distributing","_draft":false,"_partial":false,"_locale":"","title":"How to distribute?","description":"","type":"exercise","order":3,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"how-to-distribute-this-software-10-minutes"},"children":[{"type":"text","value":"How to distribute this software? (10 minutes)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Below are two cases where a researcher comes to you with a description of software they\nhave created and that they would like to distribute. Your challenge is to pick one and\nfigure out what to advise them on how best to get the software in the hands of its\naudience. Which questions would you ask to get to the bottom of things?"}]},{"type":"element","tag":"h3","props":{"id":"case-1-the-solar-solution"},"children":[{"type":"text","value":"Case 1: The Solar Solution"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Shamash is a senior researcher who leads a group. He shows up one day to ask for advice\non distributing some software that a junior researcher in his group has created. He\nsays: \"One of my people has made an amazing application for calculating where you can\nbest put solar panels, and how much energy they will produce. We think there are lots of\nresearchers studying the energy transition and working on solutions, and they should all\nuse our program because it's just so great. We're submitting a paper on solar panels in\nthe province next week, but how do we make the code available?\""}]},{"type":"element","tag":"h3","props":{"id":"case-2-the-miracle-model"},"children":[{"type":"text","value":"Case 2: The Miracle Model"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Marina is a young historian who studies historical natural disasters, who sends an email\nto ask for advice. She writes:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"text","value":"\nDear research software support,\n"},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I've been researching historical flood events in The Netherlands, and how they have\naffected politics and the economy. It's a fascinating topic that is also highly relevant\ntoday, as climate change-induced sea level rise is going to put low-lying areas around\nthe world at risk of flooding."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I actually have a background in economics, so unlike most of my colleagues in the\nhumanities I've tried to take a quantitative approach, which is quite difficult because\nwe don't have much data and floods are quite rare. I've been working with a statistician\nwho specialises in rare events and we've modified some of the existing techniques a bit\nto work better for this case, and we got some really good results."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We submitted a paper some time ago, and now I've been asked to share the code. I don't\nknow how to do that though. Can you help me?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Thanks in advance,"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Marina"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"how-to-distribute-this-software-10-minutes","depth":2,"text":"How to distribute this software? (10 minutes)","children":[{"id":"case-1-the-solar-solution","depth":3,"text":"Case 1: The Solar Solution"},{"id":"case-2-the-miracle-model","depth":3,"text":"Case 2: The Miracle Model"}]}]}},"_type":"markdown","_id":"local_fs:modules:distributing:exercise-distributing.md","_source":"local_fs","_file":"modules/distributing/exercise-distributing.md","_stem":"modules/distributing/exercise-distributing","_extension":"md","plainText":"---\ntitle: How to distribute?\ntype: exercise\norder: 3\n---\n\n## How to distribute this software? (10 minutes)\n\nBelow are two cases where a researcher comes to you with a description of software they\nhave created and that they would like to distribute. Your challenge is to pick one and\nfigure out what to advise them on how best to get the software in the hands of its\naudience. Which questions would you ask to get to the bottom of things?\n\n### Case 1: The Solar Solution\n\nShamash is a senior researcher who leads a group. He shows up one day to ask for advice\non distributing some software that a junior researcher in his group has created. He\nsays: \"One of my people has made an amazing application for calculating where you can\nbest put solar panels, and how much energy they will produce. We think there are lots of\nresearchers studying the energy transition and working on solutions, and they should all\nuse our program because it's just so great. We're submitting a paper on solar panels in\nthe province next week, but how do we make the code available?\"\n\n### Case 2: The Miracle Model\n\nMarina is a young historian who studies historical natural disasters, who sends an email\nto ask for advice. She writes:\n\n<blockquote>\nDear research software support,\n\nI've been researching historical flood events in The Netherlands, and how they have\naffected politics and the economy. It's a fascinating topic that is also highly relevant\ntoday, as climate change-induced sea level rise is going to put low-lying areas around\nthe world at risk of flooding.\n\nI actually have a background in economics, so unlike most of my colleagues in the\nhumanities I've tried to take a quantitative approach, which is quite difficult because\nwe don't have much data and floods are quite rare. I've been working with a statistician\nwho specialises in rare events and we've modified some of the existing techniques a bit\nto work better for this case, and we got some really good results.\n\nWe submitted a paper some time ago, and now I've been asked to share the code. I don't\nknow how to do that though. Can you help me?\n\nThanks in advance,\n\nMarina\n</blockquote>\n\n"},{"_path":"/modules/distributing/distributing","_dir":"distributing","_draft":false,"_partial":false,"_locale":"","title":"Distributing Software","description":"Modern software consists of an often large collection of components (libraries, packages) that are combined together to form an application. This whole collection needs to be reproduced on the computer of the user for things to work. There are two ways of doing that:","type":"reading","order":4,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"distributing-software-10-minutes"},"children":[{"type":"text","value":"Distributing software (10 minutes)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Modern software consists of an often large collection of components (libraries, packages) that are combined together to form an application. This whole collection needs to be reproduced on the computer of the user for things to work. There are two ways of doing that:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"combining them all together on the computer of the developer, and then wrapping everything up into a package, installer, container image, or VM image that is sent to the user, or"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"putting the components that you made yourself on the Internet (as a package), and relying on the user to download the other components (packages) and assembling it all together into a working application"}]}]},{"type":"element","tag":"h2","props":{"id":"monolithic-applications"},"children":[{"type":"text","value":"Monolithic applications"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Option 1) works for applications, which are more or less independent. If they're used together, then it's by saving a file from one and opening it in another application. Each application contains all the bits it needs, and is installed on the user's computer in a separate folder, away from everything else. That means that different applications don't get in each other's way, but it's also rather inefficient if many applications use the same component, because you end up with many copies of that component."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If you do choose option 1), then you still have a choice between making a package, an installer, a container image, or a virtual machine image. A package is an archive (think a ZIP-file, which it often literally is) that contains, in this case, all the components needed by the application. Since it's just a file, a package needs to be installed by a special program called a package manager. The App Store or Play Store on your phone is such a program."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"An installer is itself a computer program, that also contains all the components needed by the application. It gets downloaded by the user, who then runs it, after which it copies all the components from within itself onto the user's computer. It can then run there just like an application installed from a package using a package manager."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A container image is a special kind of package. It also contains all the parts needed to run a program, but it is run in a special isolated environment called a container. A normal application can access everything else on the computer, including files and parts of other applications. It's set up to use its own components of course, but it could access other things if it wanted or needed to. An application that runs in a container can't do this, it's isolated from everything else except for the operating system. This is an advantage for example if the software runs on a server that is accessible from the Internet, because it provides some security. It also makes it easy to run many copies of the software on many servers, so that you can serve many users."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A Virtual Machine finally is even more isolated. It contains its own operating system together with the application, so that the running application cannot even access the operating system on the user's computer. This has similar advantages as a container, being more secure, but it's also slower than using containers."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So these are the different ways option 1), distributing a monolithic application with everything included, can be implemented. As said, this reduces potential compatibility problems, but isn't very efficient because you end up with many copies of everything."}]},{"type":"element","tag":"h2","props":{"id":"separate-packages"},"children":[{"type":"text","value":"Separate packages"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Option 2) is more efficient than option 1), because the user can just install each component once, and then every other component that needs it can use it. There are drawbacks here as well though. First, the user needs to figure out which components are needed for a particular application, and then install them one by one. This puts them in an unpleasant place called \"dependency hell\"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Dependency hell was mostly solved by the invention of package managers, which automate the process of downloading and installing the required components. Example are pip, conda, apt, and Homebrew. If each component is put into a package with some metadata that describes which other packages it needs, then the package manager can do all that automatically, at least assuming that everything is Open Source and freely available online, because it cannot go to the shop to buy a license for everything. Still, often everything is Open Source and then this saves a huge amount of work. Dependency hell is not the only problem however."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software is continuously developed, and that means that it changes over time. Those changes sometimes change how a component is used by other components, which then need to be updated too. So the user may end up with an older program that only works with an older version of component X, while they also want to use a different newer program that works only with a newer version of X. A good package manager will give an error message in that case, but that doesn't solve the problem. Which version do you install?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are again two common solutions to this, distributions and environments. A distribution, like Ubuntu, is made by a group of people who create a collection of packages that are all compatible with each other, meaning that every package in it that uses package X works with the same version of package X, namely the one that's included in the distribution. This takes a significant amount of work, but it's very nice because you only have one version of everything, and maximal space efficiency. Of course there are still updates, but they happen once every six months or several years, and then everything is updated at once. That does mean that you don't get the latest version right away, but also that things just work and don't suddenly break. (Cathedral!)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another way to fix the multiple options of X problem is to use environments. An environment is a separate part of the computer into which packages can be installed, in such a way that only packages within the environment are combined. So now you can install one application in one environment with one version of X, and the other application in another environment with another version of X. That costs more disk space, but it's easier to get the latest stuff, and it doesn't require all the work of constantly ensuring everything is compatible. So this makes option 2) look a bit more like option 1) again, although you can still have fewer environments than you have applications. (Bazaar!)"}]},{"type":"element","tag":"h2","props":{"id":"which-option-to-choose-when"},"children":[{"type":"text","value":"Which option to choose when"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Scientific software is often a script, which is basically the topmost component in the whole collection of components. Scripts mostly just tell other components what to do. Since the script isn't used by other components, it can be packaged as an application in either of the above-mentioned ways. Users can then install and run it to "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"reproduce"}]},{"type":"text","value":" the results, but not easily use it in their own script or modify it to do something different but related."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sometimes, scientists (or Research Software Engineers!) develop components that are intended for use by others in their scripts, or even in other components. Those need to be packaged as packages for a package manager, because they need to be combined with other packages on the user's computer. (The user is a programmer, in this case!) This allows the software to be "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"reused"}]},{"type":"text","value":" by others in their scripts."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, for others to be able to modify the software and perhaps contribute some new feature or fixes back to it, the source code of the software needs to be available through a public repository. Package managers and installers don't normally install software in a way that makes it easy to modify, as that's not what they're designed for. To be able to modify the software, you need the source code, in a version control system. So besides in a package or container repository, don't forget to make a public git repository too!"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"monolithic-applications","depth":2,"text":"Monolithic applications"},{"id":"separate-packages","depth":2,"text":"Separate packages"},{"id":"which-option-to-choose-when","depth":2,"text":"Which option to choose when"}]}},"_type":"markdown","_id":"local_fs:modules:distributing:distributing.md","_source":"local_fs","_file":"modules/distributing/distributing.md","_stem":"modules/distributing/distributing","_extension":"md","plainText":"---\ntitle: Distributing Software\ntype: reading\norder: 4\n---\n\n# Distributing software (10 minutes)\n\nModern software consists of an often large collection of components (libraries, packages) that are combined together to form an application. This whole collection needs to be reproduced on the computer of the user for things to work. There are two ways of doing that: \n\n1) combining them all together on the computer of the developer, and then wrapping everything up into a package, installer, container image, or VM image that is sent to the user, or \n2) putting the components that you made yourself on the Internet (as a package), and relying on the user to download the other components (packages) and assembling it all together into a working application\n\n## Monolithic applications\n\nOption 1) works for applications, which are more or less independent. If they're used together, then it's by saving a file from one and opening it in another application. Each application contains all the bits it needs, and is installed on the user's computer in a separate folder, away from everything else. That means that different applications don't get in each other's way, but it's also rather inefficient if many applications use the same component, because you end up with many copies of that component.\n\nIf you do choose option 1), then you still have a choice between making a package, an installer, a container image, or a virtual machine image. A package is an archive (think a ZIP-file, which it often literally is) that contains, in this case, all the components needed by the application. Since it's just a file, a package needs to be installed by a special program called a package manager. The App Store or Play Store on your phone is such a program.\n\nAn installer is itself a computer program, that also contains all the components needed by the application. It gets downloaded by the user, who then runs it, after which it copies all the components from within itself onto the user's computer. It can then run there just like an application installed from a package using a package manager.\n\nA container image is a special kind of package. It also contains all the parts needed to run a program, but it is run in a special isolated environment called a container. A normal application can access everything else on the computer, including files and parts of other applications. It's set up to use its own components of course, but it could access other things if it wanted or needed to. An application that runs in a container can't do this, it's isolated from everything else except for the operating system. This is an advantage for example if the software runs on a server that is accessible from the Internet, because it provides some security. It also makes it easy to run many copies of the software on many servers, so that you can serve many users.\n\nA Virtual Machine finally is even more isolated. It contains its own operating system together with the application, so that the running application cannot even access the operating system on the user's computer. This has similar advantages as a container, being more secure, but it's also slower than using containers.\n\nSo these are the different ways option 1), distributing a monolithic application with everything included, can be implemented. As said, this reduces potential compatibility problems, but isn't very efficient because you end up with many copies of everything.\n\n## Separate packages\n\nOption 2) is more efficient than option 1), because the user can just install each component once, and then every other component that needs it can use it. There are drawbacks here as well though. First, the user needs to figure out which components are needed for a particular application, and then install them one by one. This puts them in an unpleasant place called \"dependency hell\".\n\nDependency hell was mostly solved by the invention of package managers, which automate the process of downloading and installing the required components. Example are pip, conda, apt, and Homebrew. If each component is put into a package with some metadata that describes which other packages it needs, then the package manager can do all that automatically, at least assuming that everything is Open Source and freely available online, because it cannot go to the shop to buy a license for everything. Still, often everything is Open Source and then this saves a huge amount of work. Dependency hell is not the only problem however.\n\nSoftware is continuously developed, and that means that it changes over time. Those changes sometimes change how a component is used by other components, which then need to be updated too. So the user may end up with an older program that only works with an older version of component X, while they also want to use a different newer program that works only with a newer version of X. A good package manager will give an error message in that case, but that doesn't solve the problem. Which version do you install?\n\nThere are again two common solutions to this, distributions and environments. A distribution, like Ubuntu, is made by a group of people who create a collection of packages that are all compatible with each other, meaning that every package in it that uses package X works with the same version of package X, namely the one that's included in the distribution. This takes a significant amount of work, but it's very nice because you only have one version of everything, and maximal space efficiency. Of course there are still updates, but they happen once every six months or several years, and then everything is updated at once. That does mean that you don't get the latest version right away, but also that things just work and don't suddenly break. (Cathedral!)\n\nAnother way to fix the multiple options of X problem is to use environments. An environment is a separate part of the computer into which packages can be installed, in such a way that only packages within the environment are combined. So now you can install one application in one environment with one version of X, and the other application in another environment with another version of X. That costs more disk space, but it's easier to get the latest stuff, and it doesn't require all the work of constantly ensuring everything is compatible. So this makes option 2) look a bit more like option 1) again, although you can still have fewer environments than you have applications. (Bazaar!)\n\n## Which option to choose when\n\nScientific software is often a script, which is basically the topmost component in the whole collection of components. Scripts mostly just tell other components what to do. Since the script isn't used by other components, it can be packaged as an application in either of the above-mentioned ways. Users can then install and run it to *reproduce* the results, but not easily use it in their own script or modify it to do something different but related.\n\nSometimes, scientists (or Research Software Engineers!) develop components that are intended for use by others in their scripts, or even in other components. Those need to be packaged as packages for a package manager, because they need to be combined with other packages on the user's computer. (The user is a programmer, in this case!) This allows the software to be *reused* by others in their scripts.\n\nFinally, for others to be able to modify the software and perhaps contribute some new feature or fixes back to it, the source code of the software needs to be available through a public repository. Package managers and installers don't normally install software in a way that makes it easy to modify, as that's not what they're designed for. To be able to modify the software, you need the source code, in a version control system. So besides in a package or container repository, don't forget to make a public git repository too!\n"},{"_path":"/modules/distributing/further-reading","_dir":"distributing","_draft":false,"_partial":false,"_locale":"","title":"Further reading","description":"","type":"reading","order":5,"body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Blogpost: "},{"type":"element","tag":"a","props":{"href":"https://medium.com/kitchen-sink-data-science/software-fundamentals-for-machine-learning-series-understanding-the-why-of-vms-containers-89621cf66d23","rel":["nofollow"]},"children":[{"type":"text","value":"Understanding the “Why” of VM’s, Containers, & Virtual Environments"}]},{"type":"text","value":" Blogpost on the difference between"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"local_fs:modules:distributing:further-reading.md","_source":"local_fs","_file":"modules/distributing/further-reading.md","_stem":"modules/distributing/further-reading","_extension":"md","plainText":"---\ntitle: Further reading\ntype: reading\norder: 5\n---\n\n- Blogpost: [Understanding the “Why” of VM’s, Containers, & Virtual Environments](https://medium.com/kitchen-sink-data-science/software-fundamentals-for-machine-learning-series-understanding-the-why-of-vms-containers-89621cf66d23) Blogpost on the difference between "}]