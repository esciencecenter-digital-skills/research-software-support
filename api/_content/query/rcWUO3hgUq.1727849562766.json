[{"_path":"/modules/testing/info","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Learning objectives","description":"","type":"info","order":0,"body":{"type":"root","children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Appreciate the importance of testing software"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Understand the various benefits of testing"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Understand the types of tests and what info they convey"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get familiar with the idea of continuous integration and its importance"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"local_fs:modules:testing:info.md","_source":"local_fs","_file":"modules/testing/info.md","_extension":"md","plainText":"---\ntitle: Learning objectives\ntype: info\norder: 0\n---\n\n- Appreciate the importance of testing software\n- Understand the various benefits of testing\n- Understand the types of tests and what info they convey\n- Get familiar with the idea of continuous integration and its importance"},{"_path":"/modules/testing/slides","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Software Testing","description":"","type":"slides","order":1,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"software-testing"},"children":[{"type":"text","value":"Software Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"what-is-software-testing"},"children":[{"type":"text","value":"What is software testing?"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“Software testing is the process of evaluating and verifying that a software product or application does what it’s supposed to do. The benefits of good testing include preventing bugs and improving performance.”"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.ibm.com/topics/software-testing","rel":["nofollow"]},"children":[{"type":"text","value":"From IBM Featured Topics"}]},{"type":"text","value":" "}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"What is software testing?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing is the process of evaluating and verifying that a software and its components meet specified requirements and work as expected. Its primary purpose is to identify defects, errors, flaws, or bugs early in the development process."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing can be done manually, where a human actively uses the software to observe for defects, or automatically, where test scripts or tools are used to execute tests."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Untested software can be compared to uncalibrated experimental devices."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"risks-of-untested-research-software"},"children":[{"type":"text","value":"Risks of untested research software"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/testing-motivation1.png","width":"30%","style":"display:inline;"},"children":[]},{"type":"element","tag":"img","props":{"src":"media/testing-motivation2.png","width":"30%","style":"display:inline;"},"children":[]},{"type":"element","tag":"img","props":{"src":"media/testing-motivation3.png","width":"30%","style":"display:inline;"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" Find the complete articles "},{"type":"element","tag":"a","props":{"href":"https://www.science.org/doi/full/10.1126/science.314.5807.1856","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", "},{"type":"element","tag":"a","props":{"href":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":", and "},{"type":"element","tag":"a","props":{"href":"https://www.wired.com/2010/11/1110mars-climate-observer-report/","rel":["nofollow"]},"children":[{"type":"text","value":"here"}]},{"type":"text","value":" "}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several examples in which the lack of proper software testings resulted in serious consequences."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The first article from 2006 reports about a software flaw (a plus sign in place of a minus sign) that lead to a retraction of 5 scientific articles."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the second from 2019, researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There is also the case of the Ariane flight V88, an European Space Agency rocket which was destroyed just 40 seconds after its launch due to a software bug; see "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Ariane_flight_V88","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Ariane_flight_V88"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"why-testing-your-software"},"children":[{"type":"text","value":"Why testing your software ?"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ensure software reliability, validity, and reproducibility."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Confirm correct installation and demonstrate use."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Boost developer confidence for contributions and modifications."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Maintain expected software functionality."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Simplify and manage code complexity."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Why testing your software is so crucial?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Specifically for research software, tests are vital for ensuring the reliability, validity, and reproducibility of your scientific results."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"They help users by enabling them confirm that the software is installed correctly, providing usage examples."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tests also help other developers modify and contribute to your software. A good test suite gives collaborators confidence to make modifications without breaking existing functionalities.\nThey preserve the expected functionality of the software."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Manage complexity: Code that is easy to test is often easier to understand and maintain."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"types-of-testing"},"children":[{"type":"text","value":"Types of testing"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unit tests"}]},{"type":"text","value":": Assess individual components for correctness."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Integration tests"}]},{"type":"text","value":": Verify interactions between different parts of the software."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"System tests"}]},{"type":"text","value":": Evaluate the complete and integrated software system."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Regression tests"}]},{"type":"text","value":": Ensure new changes don’t disrupt existing functionality."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several types of software testing, each of which with its own purpose."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In unit tests each individual unit of a software is tested separately. The purpose is to ensure that each component of the software works as expected."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Integration tests are a level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The complete, integrated system is checked via the so-called system tests. The purpose here is to evaluate whether the software as a whole gives the correct outputs for given inputs."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, regression tests check for unexpected side-effects in existing features after changes."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"continuous-integration-and-continuous-deployment-cicd"},"children":[{"type":"text","value":"Continuous Integration and Continuous Deployment (CI/CD)"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/cicd_scheme.png","width":"50%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes, often several times a day, into a shared remote repository. After every integration, a working version of the project is build and the software's test suite is run automatically, making it possible to identify defects, errors, flaws, or bugs introduced by changes early in the development process. This helps keep the code up-to-date and reduces the chances of major issues when combining everyone's work."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous deployment (CD) is the next step after CI in the CI/CD pipeline shown in the figure. CD is the practice of automatically deploying every working version of the project that passes the automated testing phase to its end-users."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"benefits-of-continuous-integration"},"children":[{"type":"text","value":"Benefits of continuous integration"}]},{"type":"element","tag":"center","props":{},"children":[{"type":"element","tag":"img","props":{"src":"media/benefits_of_ci.png","width":"70%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"h2","props":{"id":"take-home-messages"},"children":[{"type":"text","value":"Take home messages"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Software testing is key for quality, reliability, and reproducibility"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unit tests verify individual components, integration tests check component interactions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"CI/CD streamline development and enhance deployment efficiency."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"==="}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.esciencecenter.nl","rel":["nofollow"]},"children":[{"type":"text","value":"www.esciencecenter.nl"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"mailto:info@esciencecenter.nl"},"children":[{"type":"text","value":"info@esciencecenter.nl"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"software-testing","depth":2,"text":"Software Testing"},{"id":"what-is-software-testing","depth":2,"text":"What is software testing?"},{"id":"risks-of-untested-research-software","depth":2,"text":"Risks of untested research software"},{"id":"why-testing-your-software","depth":2,"text":"Why testing your software ?"},{"id":"types-of-testing","depth":2,"text":"Types of testing"},{"id":"continuous-integration-and-continuous-deployment-cicd","depth":2,"text":"Continuous Integration and Continuous Deployment (CI/CD)"},{"id":"benefits-of-continuous-integration","depth":2,"text":"Benefits of continuous integration"},{"id":"take-home-messages","depth":2,"text":"Take home messages"}]}},"_type":"markdown","_id":"local_fs:modules:testing:slides.md","_source":"local_fs","_file":"modules/testing/slides.md","_extension":"md","plainText":"---\ntitle: Software Testing\ntype: slides\norder: 1\n---\n\n<!-- .slide: data-state=\"title\" -->\n\n## Software Testing\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## What is software testing?\n\n> “Software testing is the process of evaluating and verifying that a software product or application does what it’s supposed to do. The benefits of good testing include preventing bugs and improving performance.”\n\n<small>[From IBM Featured Topics](https://www.ibm.com/topics/software-testing) </small>\n\nNote:\n\nWhat is software testing?\n\nSoftware testing is the process of evaluating and verifying that a software and its components meet specified requirements and work as expected. Its primary purpose is to identify defects, errors, flaws, or bugs early in the development process.\n\nSoftware testing can be done manually, where a human actively uses the software to observe for defects, or automatically, where test scripts or tools are used to execute tests.\n\nUntested software can be compared to uncalibrated experimental devices.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Risks of untested research software\n\n<center>\n<img src=\"media/testing-motivation1.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation2.png\" width=\"30%\" style=\"display:inline;\">\n<img src=\"media/testing-motivation3.png\" width=\"30%\" style=\"display:inline;\">\n</center>\n\n\n<small> Find the complete articles [here](https://www.science.org/doi/full/10.1126/science.314.5807.1856), [here](https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/), and [here](https://www.wired.com/2010/11/1110mars-climate-observer-report/) </small>\n\nNote:\n\nThere are several examples in which the lack of proper software testings resulted in serious consequences.\n\nThe first article from 2006 reports about a software flaw (a plus sign in place of a minus sign) that lead to a retraction of 5 scientific articles.\n\nIn the second from 2019, researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies.\n\nThe loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake.\n\nThere is also the case of the Ariane flight V88, an European Space Agency rocket which was destroyed just 40 seconds after its launch due to a software bug; see https://en.wikipedia.org/wiki/Ariane_flight_V88.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Why testing your software ?\n\n- Ensure software reliability, validity, and reproducibility.\n- Confirm correct installation and demonstrate use.\n- Boost developer confidence for contributions and modifications.\n- Maintain expected software functionality.\n- Simplify and manage code complexity.\n\nNote:\n\nWhy testing your software is so crucial?\n\nSpecifically for research software, tests are vital for ensuring the reliability, validity, and reproducibility of your scientific results.\n\nThey help users by enabling them confirm that the software is installed correctly, providing usage examples.\n\nTests also help other developers modify and contribute to your software. A good test suite gives collaborators confidence to make modifications without breaking existing functionalities.\nThey preserve the expected functionality of the software.\n\nManage complexity: Code that is easy to test is often easier to understand and maintain.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Types of testing\n\n- **Unit tests**: Assess individual components for correctness.\n- **Integration tests**: Verify interactions between different parts of the software.\n- **System tests**: Evaluate the complete and integrated software system.\n- **Regression tests**: Ensure new changes don’t disrupt existing functionality.\n\nNote:\n\nThere are several types of software testing, each of which with its own purpose.\n\nIn unit tests each individual unit of a software is tested separately. The purpose is to ensure that each component of the software works as expected.\n\nIntegration tests are a level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units.\n\nThe complete, integrated system is checked via the so-called system tests. The purpose here is to evaluate whether the software as a whole gives the correct outputs for given inputs.\n\nFinally, regression tests check for unexpected side-effects in existing features after changes.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Continuous Integration and Continuous Deployment (CI/CD)\n\n<center>\n<img src=\"media/cicd_scheme.png\" width=\"50%\">\n</center>\n\nNote:\n\nContinuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes, often several times a day, into a shared remote repository. After every integration, a working version of the project is build and the software's test suite is run automatically, making it possible to identify defects, errors, flaws, or bugs introduced by changes early in the development process. This helps keep the code up-to-date and reduces the chances of major issues when combining everyone's work.\n\nContinuous deployment (CD) is the next step after CI in the CI/CD pipeline shown in the figure. CD is the practice of automatically deploying every working version of the project that passes the automated testing phase to its end-users.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Benefits of continuous integration\n\n<center>\n<img src=\"media/benefits_of_ci.png\" width=\"70%\">\n</center>\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Take home messages\n\n- Software testing is key for quality, reliability, and reproducibility\n- Unit tests verify individual components, integration tests check component interactions\n- CI/CD streamline development and enhance deployment efficiency.\n\n===\n\n<!-- .slide: data-state=\"keepintouch\" -->\n\n\nwww.esciencecenter.nl\n\ninfo@esciencecenter.nl\n"},{"_path":"/modules/testing/software-testing","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Software Testing","description":"","type":"reading","order":2,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"software-testing-5-minutes"},"children":[{"type":"text","value":"Software Testing (5 minutes)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Software testing is the process of evaluating and verifying that software and its components meet specified requirements and function as expected. This critical step in the software development lifecycle ensures that the final product is reliable, functional, and free of significant defects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The primary goal of software testing is to identify defects, errors, flaws, or bugs early in the development process. By detecting issues early, developers can address them before the software is released, reducing the risk of costly fixes and enhancing overall quality. Software testing can be conducted manually, where a human tester actively uses the software, performing various actions and observing the results to detect any anomalies or unexpected behavior. Alternatively, automated testing utilizes test scripts or tools to execute tests automatically, which is efficient for repetitive tasks and can quickly cover a wide range of test scenarios."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Untested software can be likened to uncalibrated experimental devices. Just as uncalibrated instruments may provide inaccurate data and lead to erroneous conclusions, untested software can contain hidden defects that compromise its reliability and performance, potentially leading to critical failures in real-world applications; see optional section below."}]},{"type":"element","tag":"h3","props":{"id":"what-can-tests-help-you-do"},"children":[{"type":"text","value":"What can tests help you do?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tests play a crucial role in ensuring the reliability, validity, and reproducibility of your software's results. They help users easily verify that they have correctly installed your software, often providing examples of how to use it effectively. Tests also enable other developers to contribute to your software and make modifications with confidence, knowing that nothing is breaking."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Additionally, tests preserve expected functionality by ensuring that new changes do not introduce unintended side effects. They manage complexity by encouraging code that is easier to test, which in turn makes it easier to understand and maintain."}]},{"type":"element","tag":"h3","props":{"id":"types-of-testing"},"children":[{"type":"text","value":"Types of Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several types of tests used in software development, each serving a specific purpose to ensure the quality and functionality of the software."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Smoke Tests"}]},{"type":"text","value":": Also known as \"verification testing\", \"confidence testing\" or \"sanity testing\", smoke tests are a preliminary type of testing that checks the basic functionality of the software. They are often used to determine if a new build is stable enough to proceed with more detailed testing. Smoke tests quickly identify major issues that could prevent the software from functioning at a basic level."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Unit Tests"}]},{"type":"text","value":": These tests focus on individual functions or components of the software, testing them one at a time. Unit tests are designed to validate that each function performs as expected in isolation, ensuring that the smallest parts of the codebase work correctly."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Integration Tests"}]},{"type":"text","value":": These tests evaluate how different parts of the software work together. Integration tests are crucial for identifying issues that arise when components interact, ensuring that the integrated parts function seamlessly as a whole."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"System Tests"}]},{"type":"text","value":": These tests involve evaluating the entire software system running in an environment that simulates real-world conditions. System tests aim to verify that the software meets all specified requirements and performs well under expected usage scenarios."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Regression Tests"}]},{"type":"text","value":": These tests are used to ensure that recent code changes have not adversely affected existing functionality. By checking that the software produces the same results as before the changes, regression tests help maintain stability and prevent the reintroduction of previously fixed bugs."}]}]},{"type":"element","tag":"h2","props":{"id":"examples-of-untested-research-software-40-minutes-optional"},"children":[{"type":"text","value":"Examples of untested research software (40 minutes, optional)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"There are several examples in which the lack of proper software testings resulted in serious consequences. Here are a few interesting cases:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Therac-25","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Therac-25"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(1980) A tragic example of software bugs leading to loss of life, the Therac-25 radiation therapy machine had a flaw in its software, which resulted in patients receiving lethal doses of radiation."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Ariane_flight_V88","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Ariane_flight_V88"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(1996) This European Space Agency rocket was destroyed just 40 seconds after its launch due to a software bug."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.wired.com/2010/11/1110mars-climate-observer-report/","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.wired.com/2010/11/1110mars-climate-observer-report/"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(1999) The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Year_2000_problem","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Year_2000_problem"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2000) The Y2K bug was a widespread computer flaw that was expected to cause chaos as the date changed from December 31, 1999, to January 1, 2000."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.science.org/doi/full/10.1126/science.314.5807.1856","rel":["nofollow"]},"children":[{"type":"text","value":"https://www.science.org/doi/full/10.1126/science.314.5807.1856"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2006) A software flaw (a plus sign which should have been a minus) lead to a retraction of 5 scientific articles."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Knight_Capital_Group","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Knight_Capital_Group"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2013) Knight Capital, a financial services firm, lost around $440 million within less than an hour due to a software glitch in its trading algorithms."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings","rel":["nofollow"]},"children":[{"type":"text","value":"https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2018-2019) Software issues with the Boeing 737 MAX's Maneuvering Characteristics Augmentation System (MCAS) were implicated in two fatal crashes"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/","rel":["nofollow"]},"children":[{"type":"text","value":"https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"(2019) Researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"software-testing-5-minutes","depth":2,"text":"Software Testing (5 minutes)","children":[{"id":"what-can-tests-help-you-do","depth":3,"text":"What can tests help you do?"},{"id":"types-of-testing","depth":3,"text":"Types of Testing"}]},{"id":"examples-of-untested-research-software-40-minutes-optional","depth":2,"text":"Examples of untested research software (40 minutes, optional)"}]}},"_type":"markdown","_id":"local_fs:modules:testing:software-testing.md","_source":"local_fs","_file":"modules/testing/software-testing.md","_extension":"md","plainText":"---\ntitle: Software Testing\ntype: reading\norder: 2\n---\n\n## Software Testing (5 minutes)\n\nSoftware testing is the process of evaluating and verifying that software and its components meet specified requirements and function as expected. This critical step in the software development lifecycle ensures that the final product is reliable, functional, and free of significant defects.\n\nThe primary goal of software testing is to identify defects, errors, flaws, or bugs early in the development process. By detecting issues early, developers can address them before the software is released, reducing the risk of costly fixes and enhancing overall quality. Software testing can be conducted manually, where a human tester actively uses the software, performing various actions and observing the results to detect any anomalies or unexpected behavior. Alternatively, automated testing utilizes test scripts or tools to execute tests automatically, which is efficient for repetitive tasks and can quickly cover a wide range of test scenarios.\n\nUntested software can be likened to uncalibrated experimental devices. Just as uncalibrated instruments may provide inaccurate data and lead to erroneous conclusions, untested software can contain hidden defects that compromise its reliability and performance, potentially leading to critical failures in real-world applications; see optional section below.\n\n### What can tests help you do?\n\nTests play a crucial role in ensuring the reliability, validity, and reproducibility of your software's results. They help users easily verify that they have correctly installed your software, often providing examples of how to use it effectively. Tests also enable other developers to contribute to your software and make modifications with confidence, knowing that nothing is breaking.\n\nAdditionally, tests preserve expected functionality by ensuring that new changes do not introduce unintended side effects. They manage complexity by encouraging code that is easier to test, which in turn makes it easier to understand and maintain.\n\n### Types of Testing\n\nThere are several types of tests used in software development, each serving a specific purpose to ensure the quality and functionality of the software.\n\n- **Smoke Tests**: Also known as \"verification testing\", \"confidence testing\" or \"sanity testing\", smoke tests are a preliminary type of testing that checks the basic functionality of the software. They are often used to determine if a new build is stable enough to proceed with more detailed testing. Smoke tests quickly identify major issues that could prevent the software from functioning at a basic level.\n\n- **Unit Tests**: These tests focus on individual functions or components of the software, testing them one at a time. Unit tests are designed to validate that each function performs as expected in isolation, ensuring that the smallest parts of the codebase work correctly.\n\n- **Integration Tests**: These tests evaluate how different parts of the software work together. Integration tests are crucial for identifying issues that arise when components interact, ensuring that the integrated parts function seamlessly as a whole.\n\n- **System Tests**: These tests involve evaluating the entire software system running in an environment that simulates real-world conditions. System tests aim to verify that the software meets all specified requirements and performs well under expected usage scenarios.\n\n- **Regression Tests**: These tests are used to ensure that recent code changes have not adversely affected existing functionality. By checking that the software produces the same results as before the changes, regression tests help maintain stability and prevent the reintroduction of previously fixed bugs.\n\n## Examples of untested research software (40 minutes, optional)\n\nThere are several examples in which the lack of proper software testings resulted in serious consequences. Here are a few interesting cases:\n\n- https://en.wikipedia.org/wiki/Therac-25\n  - (1980) A tragic example of software bugs leading to loss of life, the Therac-25 radiation therapy machine had a flaw in its software, which resulted in patients receiving lethal doses of radiation.\n\n- https://en.wikipedia.org/wiki/Ariane_flight_V88\n  - (1996) This European Space Agency rocket was destroyed just 40 seconds after its launch due to a software bug.\n\n- https://www.wired.com/2010/11/1110mars-climate-observer-report/\n  - (1999) The loss of the Mars Climate Orbiter in 1999 is another prominent example of a catastrophe caused by a software error, specifically a unit conversion mistake.\n\n- https://en.wikipedia.org/wiki/Year_2000_problem\n  - (2000) The Y2K bug was a widespread computer flaw that was expected to cause chaos as the date changed from December 31, 1999, to January 1, 2000.\n\n- https://www.science.org/doi/full/10.1126/science.314.5807.1856\n  - (2006) A software flaw (a plus sign which should have been a minus) lead to a retraction of 5 scientific articles.\n\n- https://en.wikipedia.org/wiki/Knight_Capital_Group\n  - (2013) Knight Capital, a financial services firm, lost around $440 million within less than an hour due to a software glitch in its trading algorithms.\n\n- https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings\n  - (2018-2019) Software issues with the Boeing 737 MAX's Maneuvering Characteristics Augmentation System (MCAS) were implicated in two fatal crashes\n\n- https://arstechnica.com/information-technology/2019/10/chemists-discover-cross-platform-python-scripts-not-so-cross-platform/\n  - (2019) Researchers found that a programming error in a set of Python scripts commonly used for computational analysis of chemistry data returned varying results based on which operating system they were run on—throwing doubt on the results of more than 150 published chemistry studies."},{"_path":"/modules/testing/ci-cd","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Continuous Integration","description":"","type":"reading","order":3,"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"continuous-integration-ci-2-minutes"},"children":[{"type":"text","value":"Continuous Integration (CI) (2 minutes)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes into a shared remote repository, often several times a day. After each integration, a working version of the project is built, and the software's test suite is run automatically. This process allows for the early identification of defects, errors, flaws, or bugs introduced by changes, helping to maintain code quality and reduce the chances of major issues when combining everyone's work."}]},{"type":"element","tag":"h3","props":{"id":"importance-of-ci"},"children":[{"type":"text","value":"Importance of CI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CI offers several key benefits:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Early Bug Detection"}]},{"type":"text","value":": By identifying bugs early, CI minimizes their impact and makes them easier to fix."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Synchronization"}]},{"type":"text","value":": Keeps project contributors up to date with each other’s work, allowing them to benefit from new features as soon as possible."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Encouragement to Write Tests"}]},{"type":"text","value":": Promotes the practice of writing tests, ensuring better code quality."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Test Automation"}]},{"type":"text","value":": Automates the process of running tests, saving time and effort."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Frequent Testing"}]},{"type":"text","value":": Ensures that tests are run frequently, maintaining continuous validation of the software's functionality."}]}]},{"type":"element","tag":"h2","props":{"id":"continuous-deployment-cd-1-minute"},"children":[{"type":"text","value":"Continuous Deployment (CD) (1 minute)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Continuous Deployment (CD) is an extension of the CI practice that automates the release of software updates to users. This is done for every change that passes all stages of the development pipeline, including automated tests. CD ensures that the software is always in a releasable state and that new features, improvements, and bug fixes are delivered to users quickly and consistently."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Together, CI and CD form a powerful combination that enhances the efficiency, reliability, and speed of the software development process."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"continuous-integration-ci-2-minutes","depth":2,"text":"Continuous Integration (CI) (2 minutes)","children":[{"id":"importance-of-ci","depth":3,"text":"Importance of CI"}]},{"id":"continuous-deployment-cd-1-minute","depth":2,"text":"Continuous Deployment (CD) (1 minute)"}]}},"_type":"markdown","_id":"local_fs:modules:testing:ci-cd.md","_source":"local_fs","_file":"modules/testing/ci-cd.md","_extension":"md","plainText":"---\ntitle: Continuous Integration\ntype: reading\norder: 3\n---\n\n## Continuous Integration (CI) (2 minutes)\nContinuous Integration (CI) is a practice in software development where team members regularly integrate their individual code changes into a shared remote repository, often several times a day. After each integration, a working version of the project is built, and the software's test suite is run automatically. This process allows for the early identification of defects, errors, flaws, or bugs introduced by changes, helping to maintain code quality and reduce the chances of major issues when combining everyone's work.\n\n### Importance of CI\nCI offers several key benefits:\n\n- **Early Bug Detection**: By identifying bugs early, CI minimizes their impact and makes them easier to fix.\n- **Synchronization**: Keeps project contributors up to date with each other’s work, allowing them to benefit from new features as soon as possible.\n- **Encouragement to Write Tests**: Promotes the practice of writing tests, ensuring better code quality.\n- **Test Automation**: Automates the process of running tests, saving time and effort.\n- **Frequent Testing**: Ensures that tests are run frequently, maintaining continuous validation of the software's functionality.\n\n## Continuous Deployment (CD) (1 minute)\nContinuous Deployment (CD) is an extension of the CI practice that automates the release of software updates to users. This is done for every change that passes all stages of the development pipeline, including automated tests. CD ensures that the software is always in a releasable state and that new features, improvements, and bug fixes are delivered to users quickly and consistently.\n\nTogether, CI and CD form a powerful combination that enhances the efficiency, reliability, and speed of the software development process."},{"_path":"/modules/testing/exercise1","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Exercise 1","description":"Choose an alternative that correctly answers the following questions:","type":"exercise","order":4,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"exercise-1"},"children":[{"type":"text","value":"Exercise 1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Choose an alternative that correctly answers the following questions:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.1 What is software testing?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a) A method for evaluating a software's compatibility with different operating systems."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"b) The process of releasing updates and patches for software."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c) The process of verifying and validating that a software meets the required specifications and works as intended."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"d) A step in the software lifecycle focused on community engagement and feedback."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"e) The practice of documenting software functionalities."}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"1.2 Why is software testing important?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a) To build and maintain the community's trust by demonstrating commitment to quality."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"b) To identify and fix bugs, ensure the software meets required standards, and assess its reliability and reproducibility."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c) To design the software's user interface and graphics."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"d) To accelerate the overall software development process."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"e) To facilitate easier collaboration among developers."}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"answers:"}]},{"type":"text","value":"\n1.1 c)\n1.2 The most obvious answer is b), but in fact all answers except c) are correct\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"local_fs:modules:testing:exercise1.md","_source":"local_fs","_file":"modules/testing/exercise1.md","_extension":"md","plainText":"---\ntitle: Exercise 1\ntype: exercise\norder: 4\n---\n\n# Exercise 1\n\nChoose an alternative that correctly answers the following questions:\n\n**1.1 What is software testing?**\n\na) A method for evaluating a software's compatibility with different operating systems.\n\nb) The process of releasing updates and patches for software.\n\nc) The process of verifying and validating that a software meets the required specifications and works as intended.\n\nd) A step in the software lifecycle focused on community engagement and feedback.\n\ne) The practice of documenting software functionalities.\n\n---\n\n**1.2 Why is software testing important?**\n\na) To build and maintain the community's trust by demonstrating commitment to quality.\n\nb) To identify and fix bugs, ensure the software meets required standards, and assess its reliability and reproducibility.\n\nc) To design the software's user interface and graphics.\n\nd) To accelerate the overall software development process.\n\ne) To facilitate easier collaboration among developers.\n\n---\n\n<small> **answers:** \n1.1 c) \n1.2 The most obvious answer is b), but in fact all answers except c) are correct\n</small>\n"},{"_path":"/modules/testing/exercise2","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Exercise 2","description":"","type":"exercise","order":5,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"exercise-2"},"children":[{"type":"text","value":"Exercise 2"}]},{"type":"element","tag":"h2","props":{"id":"instructions"},"children":[{"type":"text","value":"Instructions"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Match the items in Column A with their corresponding items in Column B."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Write the letter of the correct match next to each item in Column A."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Have fun and learn!"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"exercise"},"children":[{"type":"text","value":"Exercise"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Column A: Test Type"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Match"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"Column B: Description"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"1. Smoke Test"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"A. Style of testing that focuses on retesting after changes are made. The results of tests after the changes are compared to the results before, and errors are raised if these are different. The purpose of this test is to ensure that changes (enhancements or defect fixes) to the software have not adversely affected it."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"2. Unit Test"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"B. A level of the software testing process where the complete, integrated system is tested. The purpose of this test is to evaluate whether the system as a whole gives the correct outputs for given inputs."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"3. Integration Test"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"C. Very brief initial checks that ensure the basic units required to run the software can be initialized. If these fail there is no point proceeding to additional levels of testing until they are fixed."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"4. System Test"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"D. A level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units."}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"5. Regression Test"}]},{"type":"element","tag":"td","props":{},"children":[]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"E. A level of the software testing process where individual units of a software are tested. The purpose is to ensure that each unit of the software works as expected."}]}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"hint"},"children":[{"type":"text","value":"Hint"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Here’s an analogy: during the process of manufacturing a ballpoint pen, the cap, the body, the tail, the ink cartridge and the ballpoint are produced separately and unit tested separately. When two or more units are ready, they are assembled and integration testing is performed, for example a test to check the cap fits on the body. When the complete pen is integrated, system testing is performed to check it can be used to write like any pen should."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" correct answers: 1.C., 2.E., 3.D., 4.B., and 5.A "}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"instructions","depth":2,"text":"Instructions"},{"id":"exercise","depth":2,"text":"Exercise"},{"id":"hint","depth":2,"text":"Hint"}]}},"_type":"markdown","_id":"local_fs:modules:testing:exercise2.md","_source":"local_fs","_file":"modules/testing/exercise2.md","_extension":"md","plainText":"---\ntitle: Exercise 2\ntype: exercise\norder: 5\n---\n\n# Exercise 2\n\n## Instructions\n\n- Match the items in Column A with their corresponding items in Column B.\n- Write the letter of the correct match next to each item in Column A.\n- Have fun and learn!\n\n---\n\n## Exercise\n\n| Column A: Test Type  | Match | Column B: Description |\n|----------------------|-------|-----------------------|\n| 1. Smoke Test        |       | A. Style of testing that focuses on retesting after changes are made. The results of tests after the changes are compared to the results before, and errors are raised if these are different. The purpose of this test is to ensure that changes (enhancements or defect fixes) to the software have not adversely affected it. |\n| 2. Unit Test         |       | B. A level of the software testing process where the complete, integrated system is tested. The purpose of this test is to evaluate whether the system as a whole gives the correct outputs for given inputs. |\n| 3. Integration Test  |       | C. Very brief initial checks that ensure the basic units required to run the software can be initialized. If these fail there is no point proceeding to additional levels of testing until they are fixed. |\n| 4. System Test       |       | D. A level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units. |\n| 5. Regression Test   |       | E. A level of the software testing process where individual units of a software are tested. The purpose is to ensure that each unit of the software works as expected. | \n\n---\n\n## Hint\n\nHere’s an analogy: during the process of manufacturing a ballpoint pen, the cap, the body, the tail, the ink cartridge and the ballpoint are produced separately and unit tested separately. When two or more units are ready, they are assembled and integration testing is performed, for example a test to check the cap fits on the body. When the complete pen is integrated, system testing is performed to check it can be used to write like any pen should.\n\n<small> correct answers: 1.C., 2.E., 3.D., 4.B., and 5.A </small>\n\n"},{"_path":"/modules/testing/exercise3","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Exercise 3","description":"","type":"exercise","order":6,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"exercise-3"},"children":[{"type":"text","value":"Exercise 3"}]},{"type":"element","tag":"h2","props":{"id":"scenario"},"children":[{"type":"text","value":"Scenario"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"You are part of a research team working on a complex simulation software that models climate change. The software is developed collaboratively by a diverse group of scientists, each contributing to different modules (e.g., ocean temperature modeling, atmospheric chemistry, etc.). The team has faced issues with code integration, where new contributions occasionally break existing functionalities or cause unexpected results, leading to delays in their research. You are considering the adoption of "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Continuous Integration"}]},{"type":"text","value":"."}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"question"},"children":[{"type":"text","value":"Question"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Which of the following best describes Continuous Integration and its benefits for this project?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"a) Continuous Integration is a practice where team members work in isolation to ensure their code is perfect before integrating it once at the end of the project, helping to avoid conflicts and errors."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"b) Continuous Integration involves the use of specialized software to automatically translate code into multiple programming languages, making it more versatile and reducing workload."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"c) Continuous Integration is a development practice where team members frequently integrate their work, often several times a day, to detect and fix integration issues early, thereby improving collaboration and code quality."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"d) Continuous Integration is a method where team members manually review each other's code at the end of each day, ensuring that the code meets quality standards and is ready for client presentation."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"e) Continuous Integration refers to the continuous updating of software to incorporate user feedback and new features, ensuring the software evolves to meet user needs."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"small","props":{},"children":[{"type":"text","value":" correct answer: c) "}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"scenario","depth":2,"text":"Scenario"},{"id":"question","depth":2,"text":"Question"}]}},"_type":"markdown","_id":"local_fs:modules:testing:exercise3.md","_source":"local_fs","_file":"modules/testing/exercise3.md","_extension":"md","plainText":"---\ntitle: Exercise 3\ntype: exercise\norder: 6\n---\n\n# Exercise 3\n\n## Scenario\n\nYou are part of a research team working on a complex simulation software that models climate change. The software is developed collaboratively by a diverse group of scientists, each contributing to different modules (e.g., ocean temperature modeling, atmospheric chemistry, etc.). The team has faced issues with code integration, where new contributions occasionally break existing functionalities or cause unexpected results, leading to delays in their research. You are considering the adoption of **Continuous Integration**.\n\n---\n\n## Question\n\nWhich of the following best describes Continuous Integration and its benefits for this project?\n\na) Continuous Integration is a practice where team members work in isolation to ensure their code is perfect before integrating it once at the end of the project, helping to avoid conflicts and errors.\n\nb) Continuous Integration involves the use of specialized software to automatically translate code into multiple programming languages, making it more versatile and reducing workload.\n\nc) Continuous Integration is a development practice where team members frequently integrate their work, often several times a day, to detect and fix integration issues early, thereby improving collaboration and code quality.\n\nd) Continuous Integration is a method where team members manually review each other's code at the end of each day, ensuring that the code meets quality standards and is ready for client presentation.\n\ne) Continuous Integration refers to the continuous updating of software to incorporate user feedback and new features, ensuring the software evolves to meet user needs.\n\n<small> correct answer: c) </small>"},{"_path":"/modules/testing/reading","_dir":"testing","_draft":false,"_partial":false,"_locale":"","title":"Reading material","description":"","type":"reading","order":7,"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"reading-material"},"children":[{"type":"text","value":"Reading material"}]},{"type":"element","tag":"h2","props":{"id":"testing"},"children":[{"type":"text","value":"Testing"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Follow the links below to read more about software testing."}]},{"type":"element","tag":"h3","props":{"id":"the-turing-way"},"children":[{"type":"text","value":"The Turing Way"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in the Turing Way about "},{"type":"element","tag":"a","props":{"href":"https://the-turing-way.netlify.app/reproducible-research/testing","rel":["nofollow"]},"children":[{"type":"text","value":"Code Testing"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"code-refinery"},"children":[{"type":"text","value":"Code Refinery"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in CodeRefinery about "},{"type":"element","tag":"a","props":{"href":"https://coderefinery.github.io/testing/motivation/","rel":["nofollow"]},"children":[{"type":"text","value":"Automated testing"}]}]},{"type":"element","tag":"h3","props":{"id":"ibm"},"children":[{"type":"text","value":"IBM"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Link to an "},{"type":"element","tag":"a","props":{"href":"https://www.ibm.com/topics/software-testing","rel":["nofollow"]},"children":[{"type":"text","value":"IBM article"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"arxiv"},"children":[{"type":"text","value":"arXiv"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read this interesting article about "},{"type":"element","tag":"a","props":{"href":"https://arxiv.org/abs/2205.15982","rel":["nofollow"]},"children":[{"type":"text","value":"Testing Research Software"}]}]},{"type":"element","tag":"h2","props":{"id":"cicd"},"children":[{"type":"text","value":"CI/CD"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Follow the links below to read more about CI/CD."}]},{"type":"element","tag":"h3","props":{"id":"the-turing-way-1"},"children":[{"type":"text","value":"The Turing Way"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in the Turing Way about "},{"type":"element","tag":"a","props":{"href":"https://the-turing-way.netlify.app/reproducible-research/ci","rel":["nofollow"]},"children":[{"type":"text","value":"Continuous Integration"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h3","props":{"id":"code-refinery-1"},"children":[{"type":"text","value":"Code Refinery"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in CodeRefinery about "},{"type":"element","tag":"a","props":{"href":"https://coderefinery.github.io/testing/continuous-integration/","rel":["nofollow"]},"children":[{"type":"text","value":"Continuous integration"}]}]},{"type":"element","tag":"h3","props":{"id":"bytebytego-newsletter"},"children":[{"type":"text","value":"ByteByteGo Newsletter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Read in ByteByteGo newsletter about "},{"type":"element","tag":"a","props":{"href":"https://blog.bytebytego.com/p/a-crash-course-in-cicd","rel":["nofollow"]},"children":[{"type":"text","value":"A Crash Course in CI/CD"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"testing","depth":2,"text":"Testing","children":[{"id":"the-turing-way","depth":3,"text":"The Turing Way"},{"id":"code-refinery","depth":3,"text":"Code Refinery"},{"id":"ibm","depth":3,"text":"IBM"},{"id":"arxiv","depth":3,"text":"arXiv"}]},{"id":"cicd","depth":2,"text":"CI/CD","children":[{"id":"the-turing-way-1","depth":3,"text":"The Turing Way"},{"id":"code-refinery-1","depth":3,"text":"Code Refinery"},{"id":"bytebytego-newsletter","depth":3,"text":"ByteByteGo Newsletter"}]}]}},"_type":"markdown","_id":"local_fs:modules:testing:reading.md","_source":"local_fs","_file":"modules/testing/reading.md","_extension":"md","plainText":"---\ntitle: Reading material\ntype: reading\norder: 7\n---\n\n# Reading material\n\n## Testing\nFollow the links below to read more about software testing.\n\n### The Turing Way\nRead in the Turing Way about [Code Testing](https://the-turing-way.netlify.app/reproducible-research/testing).\n\n### Code Refinery\nRead in CodeRefinery about [Automated testing](https://coderefinery.github.io/testing/motivation/)\n\n### IBM\nLink to an [IBM article](https://www.ibm.com/topics/software-testing).\n\n### arXiv\nRead this interesting article about [Testing Research Software](https://arxiv.org/abs/2205.15982)\n\n## CI/CD\nFollow the links below to read more about CI/CD.\n\n### The Turing Way\nRead in the Turing Way about [Continuous Integration](https://the-turing-way.netlify.app/reproducible-research/ci).\n\n### Code Refinery\nRead in CodeRefinery about [Continuous integration](https://coderefinery.github.io/testing/continuous-integration/)\n\n### ByteByteGo Newsletter\nRead in ByteByteGo newsletter about [A Crash Course in CI/CD](https://blog.bytebytego.com/p/a-crash-course-in-cicd)"}]